#include <stdio.h>
int main(){

    /*
        数据类型中占用的字节数是不固定的,可以通过sizeof来获取

        数据类型(没有字符串类型和布尔类型)
            1.基本数据类型
                整型:
                    短整型:有符号短整型([signed] short [int]),无符号短整型(unsigned short [int])
                    基本整型:有符号基本整型([signed] int),无符号基本整型(unsigned int)
                    长整型:有符号长整型([signed] long [int]),无符号长整型([signed] long [int])
                字符型:
                    char
                浮点型:
                    float
                    double
                    long double
                枚举类型:

            2.构造类型
                数组
                结构体
                共用体
            3.指针类型
            4.空类型
    */
    unsigned int a = 1;


    // man 3 printf
    // 输出整型%d,8进制整型%o,16进制整型%x,16进制整型(ABCDEF用大写)%X,当做10进制无符号整数输出%u
    printf("%d\n",a);//1


    int b = -2;
    // 把-2当做一个无符号整数输出
    // 因为sizeof(b)==4,int类型在当前系统中占用4个字节
    // 原码
    // 10000000 00000000 00000000 00000010
    // 反码
    // 11111111 11111111 11111111 11111101
    // 补码(内存中存储的内容)
    // 11111111 11111111 11111111 11111110

    // 转换为无符号整数
    // ff ff ff fe = 15*16^7 + 15*16^6 + 15*16^5 + 15*16^4 + 15*16^3 + 15*16^2 + 15*16 + 14 = 4294967294
    // js中15*Math.pow(16,7)+15*Math.pow(16,6)+15*Math.pow(16,5)+15*Math.pow(16,4)+15*Math.pow(16,3)+15*Math.pow(16,2)+15*16+14=4294967294
    printf("%d\n",b);//-2
    printf("%x\n",b);//fffffffe,把一个数值,按照16进制的形式打印出来,能真实的反映出来内存中数据的存放形式

 

    // 对于无符号类型数据,最高位表示数值本身
    // 例如:
    unsigned short c = 0xffff; 
    printf("%x\n",c);//ffff
    printf("%d\n",c);//2^16-1=65535
    // 无符号短整形最大值是11111111 11111111=65535

    short d = 0x7fff;
    printf("%x\n",d);//7fff
    printf("%d\n",d);//2^15-1=32767
    // 无符号短整形最大值是01111111 11111111=32767




    printf("---------------\n");
    
    // 溢出测试:
    short e = 0xffff;
    // 内存中:11111111 11111111
    printf("%x\n",e);//ffff
    // 内存中存储的都是补码,这里因为是一个负数,所以如果按照10进制打印的话,要还原成原码
    // 补码:11111111 11111111
    // 反码:11111111 11111110
    // 原码:10000000000000001
    printf("%d\n",e);//-1

    e = e + 1;
    // 进行加1操作,运算是在内存中进行的,内存中存储的是补码,所以最终按照补码在内存中进行计算
    // 补码:11111111 11111111
    // 加一:00000000 00000001
    // 结果:00000000 00000000
    // 内存中变成了一个正数:正数原码和反码和补码相同，最终值为0
    printf("%d\n",e);//0




    printf("---------------\n");
    // 溢出测试:
    short f = 0x7fff;

    short size = sizeof f;
    printf("%d\n",size);//2

    // 内存中:01111111 11111111
    // 内存中存储的都是补码,这里是一个正数,原码和补码相同
    printf("%x\n",f);//7fff
    printf("%d\n",f);//2^15-1=32767
 
    f = f + (short int)1;
    // 进行加1操作,运算是在内存中进行的,内存中存储的是补码,所以最终内存中计算后还是补码
    // 补码:01111111 11111111
    // 加一:00000000 00000001
    // 结果:10000000 00000000
    // 反码:11111111 11111111
    // 原码:10000000 00000000
    printf("%x\n",f);//8000
    printf("%d\n",f);//-2^15=-32768


    return 0;
} 