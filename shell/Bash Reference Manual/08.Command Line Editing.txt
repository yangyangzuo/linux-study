



8 Command Line Editing
8命令行编辑
This chapter describes the basic features of the GNU command line editing interface. Command line editing is provided by the Readline library, which is used by several different programs, including Bash. Command line editing is enabled by default when using an interactive shell, unless the --noediting option is supplied at shell invocation. Line editing is also used when using the -e option to the read builtin command (see Bash Builtins). By default, the line editing commands are similar to those of Emacs. A vi-style line editing interface is also available. Line editing can be enabled at any time using the -o emacs or -o vi options to the set builtin command (see The Set Builtin), or disabled using the +o emacs or +o vi options to set.

本章介绍了 GNU 命令行编辑界面的基本特性。命令行编辑是由 Readline 库提供的，该库由几个不同的程序(包括 Bash)使用。在使用交互式 shell 时，默认情况下启用命令行编辑，除非在 shell 调用时提供 -- noediting 选项。当对 read builtin 命令使用 -e 选项时，也可以使用行编辑(参见 Bash Builtins)。默认情况下，行编辑命令类似于 Emacs 的命令。Vi 风格的行编辑界面也是可用的。可以在任何时候使用 Set Builtin 命令的-o emacs 或-o vi 选项(参见 The Set Builtin)启用行编辑，或者使用 + o emacs 或 + o vi 选项设置禁用行编辑。

• Introduction and Notation 简介及注释:	  	Notation used in this text. 本文中使用的符号
• Readline Interaction 读线相互作用:	  	The minimum set of commands for editing a line. 用于编辑行的最小命令集
• Readline Init File 读取 Init 文件:	  	Customizing Readline from a user’s view. 从用户视图自定义读线
• Bindable Readline Commands 可绑定的可读行命令:	  	A description of most of the Readline commands available for binding 可用于绑定的大多数 Readline 命令的说明
• Readline vi Mode 模式:	  	A short description of how to make Readline behave like the vi editor. 一个关于如何使 Readline 像 vi 编辑器一样工作的简短描述
• Programmable Completion 可编程完成:	  	How to specify the possible completions for a specific command. 如何指定特定命令的可能完成
• Programmable Completion Builtins 可编程完成内置程序:	  	Builtin commands to specify how to complete arguments for a particular command. 内置命令来指定如何完成特定命令的参数
• A Programmable Completion Example 一个可编程完成例子:	  	An example shell function for generating possible completions. 一个用于生成可能完成的示例 shell 函数
Next: Readline Interaction, Up: Command Line Editing   [Contents][Index]

接下来: Readline Interaction，Up: Command Line Editing [ Contents ][ Index ]

8.1 Introduction to Line Editing
8.1行编辑入门
The following paragraphs describe the notation used to represent keystrokes.

下面的段落描述了用于表示击键的符号。

The text C-k is read as ‘Control-K’ and describes the character produced when the k key is pressed while the Control key is depressed.

文本 C-k 被读作“ Control-K” ，并描述了当按下 k 键而按下 Control 键时所产生的字符。

The text M-k is read as ‘Meta-K’ and describes the character produced when the Meta key (if you have one) is depressed, and the k key is pressed. The Meta key is labeled ALT on many keyboards. On keyboards with two keys labeled ALT (usually to either side of the space bar), the ALT on the left side is generally set to work as a Meta key. The ALT key on the right may also be configured to work as a Meta key or may be configured as some other modifier, such as a Compose key for typing accented characters.

文本 M-k 被解读为“ Meta-K” ，并描述了当按下 Meta 键(如果有的话)和 k 键时产生的字符。许多键盘上的 Meta 键都被标记为 ALT。在键盘上有两个标记为 ALT 的键(通常在空格键的两侧) ，左侧的 ALT 键通常被设置为 Meta 键。右边的 ALT 键也可以配置为作为 Meta 键工作，或者可以配置为其他修饰符，如用于键入重音字符的 Compose 键。

If you do not have a Meta or ALT key, or another key working as a Meta key, the identical keystroke can be generated by typing ESC first, and then typing k. Either process is known as metafying the k key.

如果你没有一个 Meta 或 ALT 键，或者另一个作为 Meta 键工作的键，可以通过先输入 ESC，然后输入 k 生成相同的击键。

The text M-C-k is read as ‘Meta-Control-k’ and describes the character produced by metafying C-k.

文本 M-C-k 被解读为“ Meta-Control-k” ，并描述了元化 C-k 所产生的字符。

In addition, several keys have their own names. Specifically, DEL, ESC, LFD, SPC, RET, and TAB all stand for themselves when seen in this text, or in an init file (see Readline Init File). If your keyboard lacks a LFD key, typing C-j will produce the desired character. The RET key may be labeled Return or Enter on some keyboards.

此外，几个键有自己的名字。具体来说，DEL、 ESC、 LFD、 SPC、 RET 和 TAB 在本文中或 Init 文件中(参见 Readline Init File)都代表它们自己。如果您的键盘缺少 LFD 键，键入 C-j 将产生所需的字符。RET 键可能在某些键盘上标记为“返回”或“回车”。

Next: Readline Init File, Previous: Introduction and Notation, Up: Command Line Editing   [Contents][Index]

下一步: Readline Init File，Previous: Introduction and Notation，Up: Command Line Editing [ Contents ][ Index ]

8.2 Readline Interaction
Often during an interactive session you type in a long line of text, only to notice that the first word on the line is misspelled. The Readline library gives you a set of commands for manipulating the text as you type it in, allowing you to just fix your typo, and not forcing you to retype the majority of the line. Using these editing commands, you move the cursor to the place that needs correction, and delete or insert the text of the corrections. Then, when you are satisfied with the line, you simply press RET. You do not have to be at the end of the line to press RET; the entire line is accepted regardless of the location of the cursor within the line.

通常在交互式会话中，你输入一长行文本，却发现第一行的单词拼写错误。Readline 库为您提供了一组命令，用于在键入文本时操作文本，允许您只修复输入错误，而不必重新键入大部分行。使用这些编辑命令，可以将光标移动到需要修改的位置，并删除或插入修改文本。然后，当您对该行感到满意时，只需按 RET。您不必在行的末尾按 RET; 无论游标在行中的位置如何，都可以接受整个行。

• Readline Bare Essentials:	  	The least you need to know about Readline. 至少你需要了解 Readline
• Readline Movement Commands 读取移动命令:	  	Moving about the input line. 在输入行移动
• Readline Killing Commands 阅读杀人命令:	  	How to delete text, and how to get it back! 如何删除文本，如何获得它回来
• Readline Arguments 阅读行参数:	  	Giving numeric arguments to commands. 为命令提供数字参数
• Searching 搜索:	  	Searching through previous lines. 搜索前面的行
Next: Readline Movement Commands, Up: Readline Interaction   [Contents][Index]

下一步: 阅读行移动命令，向上: 阅读行交互[目录][索引]

8.2.1 Readline Bare Essentials
In order to enter characters into the line, simply type them. The typed character appears where the cursor was, and then the cursor moves one space to the right. If you mistype a character, you can use your erase character to back up and delete the mistyped character.

要在行中输入字符，只需键入它们。输入的字符出现在光标所在的位置，然后光标向右移动一个空格。如果您输入了一个字符，您可以使用擦除字符备份并删除输入的字符。

Sometimes you may mistype a character, and not notice the error until you have typed several other characters. In that case, you can type C-b to move the cursor to the left, and then correct your mistake. Afterwards, you can move the cursor to the right with C-f.

有时您可能会输入错误的字符，并没有注意到错误，直到您已键入几个其他字符。在这种情况下，您可以键入 C-b 将光标向左移动，然后纠正您的错误。然后，你可以用 C-f 将光标移动到右边。

When you add text in the middle of a line, you will notice that characters to the right of the cursor are ‘pushed over’ to make room for the text that you have inserted. Likewise, when you delete text behind the cursor, characters to the right of the cursor are ‘pulled back’ to fill in the blank space created by the removal of the text. A list of the bare essentials for editing the text of an input line follows.

当您在一行的中间添加文本时，您将注意到光标右侧的字符被“推倒” ，以便为您插入的文本腾出空间。同样，当您删除光标后面的文本时，光标右侧的字符将被“拉回” ，以填充由删除文本创建的空白空间。下面列出了编辑输入行文本的基本要点。

C-b
Move back one character.

后退一个字符。

C-f
Move forward one character.

向前移动一个字符。

DEL 德尔 or 或Backspace
Delete the character to the left of the cursor.

删除光标左边的字符。

C-d
Delete the character underneath the cursor.

删除光标下面的字符。

Printing characters 打印字符
Insert the character into the line at the cursor.

将字符插入光标处的行中。

C-_ or 或C-x C-u
Undo the last editing command. You can undo all the way back to an empty line.

撤消最后一个编辑命令。您可以全部撤消回到一个空行。

(Depending on your configuration, the Backspace key be set to delete the character to the left of the cursor and the DEL key set to delete the character underneath the cursor, like C-d, rather than the character to the left of the cursor.)

(根据您的配置，可以设置 Backspace 键用于删除光标左侧的字符，而 DEL 键用于删除光标下面的字符，如 C-d，而不是光标左侧的字符。)

Next: Readline Killing Commands, Previous: Readline Bare Essentials, Up: Readline Interaction   [Contents][Index]

接下来: Readline Killing command，Previous: Readline Bare Essentials，Up: Readline Interaction [ Contents ][ Index ]

8.2.2 Readline Movement Commands
8.2.2重读移动命令
The above table describes the most basic keystrokes that you need in order to do editing of the input line. For your convenience, many other commands have been added in addition to C-b, C-f, C-d, and DEL. Here are some commands for moving more rapidly about the line.

上表描述了编辑输入行所需的最基本的击键。为了方便起见，除了 C-b、 C-f、 C-d 和 del. 之外，还添加了许多其他命令。下面是一些在线路上移动得更快的命令。

C-a
Move to the start of the line.

移到队伍的起点。

C-e
Move to the end of the line.

走到队伍的末尾。

M-f
Move forward a word, where a word is composed of letters and digits.

向前移动一个单词，其中一个单词由字母和数字组成。

M-b
Move backward a word.

向后移动一个单词。

C-l
Clear the screen, reprinting the current line at the top.

清除屏幕，在顶部重新打印当前行。

Notice how C-f moves forward a character, while M-f moves forward a word. It is a loose convention that control keystrokes operate on characters while meta keystrokes operate on words.

注意 C-f 如何向前移动一个字符，而 M-f 向前移动一个单词。这是一个松散的约定，控制击键操作的字符，而元击键操作的话。

Next: Readline Arguments, Previous: Readline Movement Commands, Up: Readline Interaction   [Contents][Index]

接下来: Readline Arguments，Previous: Readline Movement Commands，Up: Readline Interaction [ Contents ][ Index ]

8.2.3 Readline Killing Commands
8.2.3重读杀人命令
Killing text means to delete the text from the line, but to save it away for later use, usually by yanking (re-inserting) it back into the line. (‘Cut’ and ‘paste’ are more recent jargon for ‘kill’ and ‘yank’.)

终止文本意味着从行中删除文本，但是为了保存它以便以后使用，通常是将它拉回行中(重新插入)。(‘ Cut’和‘ paste’是‘ kill’和‘ yank’的最新术语。)

If the description for a command says that it ‘kills’ text, then you can be sure that you can get the text back in a different (or the same) place later.

如果命令的描述说它“杀死”了文本，那么您可以确保以后可以在不同的(或相同的)位置获得该文本。

When you use a kill command, the text is saved in a kill-ring. Any number of consecutive kills save all of the killed text together, so that when you yank it back, you get it all. The kill ring is not line specific; the text that you killed on a previously typed line is available to be yanked back later, when you are typing another line.

当您使用 kill 命令时，文本将保存在 kill-ring 中。任意数量的连续杀戮都会保存所有杀死的文本，所以当你把它拉回来的时候，你会得到所有的文本。Kill ring 不是特定于行的; 您在以前输入的行上杀死的文本可以在稍后键入另一行时被拉回。

Here is the list of commands for killing text.

下面是用于删除文本的命令列表。

C-k
Kill the text from the current cursor position to the end of the line.

从当前光标位置到行尾终止文本。

M-d
Kill from the cursor to the end of the current word, or, if between words, to the end of the next word. Word boundaries are the same as those used by M-f.

杀死从光标到当前单词的结尾，或者，如果在单词之间，杀死到下一个单词的结尾。单词边界和 M-f 使用的边界是一样的。

M-DEL 德尔
Kill from the cursor the start of the current word, or, if between words, to the start of the previous word. Word boundaries are the same as those used by M-b.

从光标中删除当前单词的开头，如果在单词之间，则删除前一个单词的开头。词的边界与 M-b 使用的边界是一样的。

C-w
Kill from the cursor to the previous whitespace. This is different than M-DEL because the word boundaries differ.

从光标到前一个空格删除。这与 M-DEL 不同，因为单词边界不同。

Here is how to yank the text back into the line. Yanking means to copy the most-recently-killed text from the kill buffer.

下面是如何将文本拉回到行中。Yanking 意味着从终止缓冲区复制最近被终止的文本。

C-y
Yank the most recently killed text back into the buffer at the cursor.

将最近关闭的文本拉回到光标处的缓冲区中。

M-y
Rotate the kill-ring, and yank the new top. You can only do this if the prior command is C-y or M-y.

旋转杀伤环，并拉动新的顶部。只有在前面的命令是 C-y 或 M-y 时才能执行此操作。

Next: Searching, Previous: Readline Killing Commands, Up: Readline Interaction   [Contents][Index]

下一步: 搜索，上一步: 读线杀死命令，上一步: 读线交互[内容][索引]

8.2.4 Readline Arguments
You can pass numeric arguments to Readline commands. Sometimes the argument acts as a repeat count, other times it is the sign of the argument that is significant. If you pass a negative argument to a command which normally acts in a forward direction, that command will act in a backward direction. For example, to kill text back to the start of the line, you might type ‘M-- C-k’.

可以将数值参数传递给 Readline 命令。有时候论点起到重复计数的作用，有时候论点的符号才是重要的。如果你传递一个负参数给一个通常朝向前方的命令，那么这个命令将朝向后方。例如，要将文本删除回行首，可以键入“ m -- C-k”。

The general way to pass numeric arguments to a command is to type meta digits before the command. If the first ‘digit’ typed is a minus sign (‘-’), then the sign of the argument will be negative. Once you have typed one meta digit to get the argument started, you can type the remainder of the digits, and then the command. For example, to give the C-d command an argument of 10, you could type ‘M-1 0 C-d’, which will delete the next ten characters on the input line.

将数值参数传递给命令的一般方法是在命令前键入元数字。如果键入的第一个“数字”是一个减号(“-”) ，那么参数的符号将是负的。一旦您键入一个元数字以启动参数，您可以键入其余的数字，然后命令。例如，要给 C-d 命令一个参数为10的参数，您可以输入“ m-10c-d” ，它将删除输入行上的下10个字符。

Previous: Readline Arguments, Up: Readline Interaction   [Contents][Index]

上一页: Readline Arguments，Up: Readline Interaction [ Contents ][ Index ]

8.2.5 Searching for Commands in the History
8.2.5在历史记录中搜索命令
Readline provides commands for searching through the command history (see Bash History Facilities) for lines containing a specified string. There are two search modes: incremental and non-incremental.

Readline 提供了在命令历史记录中搜索包含指定字符串的行的命令(请参见 Bash 历史工具)。有两种搜索模式: 增量式和非增量式。

Incremental searches begin before the user has finished typing the search string. As each character of the search string is typed, Readline displays the next entry from the history matching the string typed so far. An incremental search requires only as many characters as needed to find the desired history entry. To search backward in the history for a particular string, type C-r. Typing C-s searches forward through the history. The characters present in the value of the isearch-terminators variable are used to terminate an incremental search. If that variable has not been assigned a value, the ESC and C-J characters will terminate an incremental search. C-g will abort an incremental search and restore the original line. When the search is terminated, the history entry containing the search string becomes the current line.

增量搜索在用户输入完搜索字符串之前开始。当输入搜索字符串的每个字符时，Readline 将显示历史记录中与目前输入的字符串相匹配的下一个条目。增量搜索只需要足够多的字符就可以找到所需的历史记录条目。要在历史记录中向后搜索特定的字符串，输入 C-r。输入 C-s 可以在历史记录中搜索。Isearch-terminators 变量值中的字符用于终止增量搜索。如果没有为该变量赋值，ESC 和 C-J 字符将终止增量搜索。C-g 将中止增量搜索并恢复原始行。当搜索结束时，包含搜索字符串的历史记录项成为当前行。

To find other matching entries in the history list, type C-r or C-s as appropriate. This will search backward or forward in the history for the next entry matching the search string typed so far. Any other key sequence bound to a Readline command will terminate the search and execute that command. For instance, a RET will terminate the search and accept the line, thereby executing the command from the history list. A movement command will terminate the search, make the last line found the current line, and begin editing.

若要在历史记录列表中查找其他匹配项，请酌情键入 C-r 或 C-s。这将在历史记录中向后或向前搜索匹配到目前为止输入的搜索字符串的下一个条目。绑定到 Readline 命令的任何其他键序列都将终止搜索并执行该命令。例如，RET 将终止搜索并接受该行，从而执行历史列表中的命令。移动命令将终止搜索，使最后一行找到当前行，并开始编辑。

Readline remembers the last incremental search string. If two C-rs are typed without any intervening characters defining a new search string, any remembered search string is used.

Readline 记住最后一个增量搜索字符串。如果键入了两个 C-rs，中间没有定义新搜索字符串的任何中间字符，则使用任何记住的搜索字符串。

Non-incremental searches read the entire search string before starting to search for matching history lines. The search string may be typed by the user or be part of the contents of the current line.

非增量搜索在开始搜索匹配的历史行之前读取整个搜索字符串。搜索字符串可以由用户键入，也可以作为当前行的内容的一部分。

Next: Bindable Readline Commands, Previous: Readline Interaction, Up: Command Line Editing   [Contents][Index]

下一步: 可绑定的读行命令，上一步: 读行交互，上一步: 命令行编辑[内容][索引]

8.3 Readline Init File
Although the Readline library comes with a set of Emacs-like keybindings installed by default, it is possible to use a different set of keybindings. Any user can customize programs that use Readline by putting commands in an inputrc file, conventionally in his home directory. The name of this file is taken from the value of the shell variable INPUTRC. If that variable is unset, the default is ~/.inputrc. If that file does not exist or cannot be read, the ultimate default is /etc/inputrc. The bind builtin command can also be used to set Readline keybindings and variables. See Bash Builtins.

虽然 Readline 库默认安装了一组类似 emacs 的键绑定，但是可以使用一组不同的键绑定。任何用户都可以自定义使用 Readline 的程序，方法是将命令放在一个输入文件中，通常放在他的主目录中。此文件的名称取自 shell 变量 INPUTRC 的值。如果该变量未设置，则默认值为 ~/。输入。如果该文件不存在或无法读取，最终的默认值是/etc/inputrc。Bind 内置命令还可用于设置 Readline 键绑定和变量。参见 Bash Builtins。

When a program which uses the Readline library starts up, the init file is read, and the key bindings are set.

当使用 Readline 库的程序启动时，将读取 init 文件，并设置键绑定。

In addition, the C-x C-r command re-reads this init file, thus incorporating any changes that you might have made to it.

此外，C-x C-r 命令重新读取这个 init 文件，从而合并您可能对其所做的任何更改。

• Readline Init File Syntax 文件语法:	  	Syntax for the commands in the inputrc file. Inputrc 文件中命令的语法

• Conditional Init Constructs 条件 Init 结构:	  	Conditional key bindings in the inputrc file. 输入文件中的条件密钥绑定

• Sample Init File 示例 Init 文件:	  	An example inputrc file. 一个输入文件示例
Next: Conditional Init Constructs, Up: Readline Init File   [Contents][Index]

下一步: 条件 Init 构造，向上: Readline Init File [ Contents ][ Index ]

8.3.1 Readline Init File Syntax
There are only a few basic constructs allowed in the Readline init file. Blank lines are ignored. Lines beginning with a ‘#’ are comments. Lines beginning with a ‘$’ indicate conditional constructs (see Conditional Init Constructs). Other lines denote variable settings and key bindings.

Readline init 文件中只允许一些基本构造。空行被忽略。以 # 开头的行是注释。以“ $”开头的行表示条件结构(请参阅条件 Init 结构)。其他行表示变量设置和键绑定。

Variable Settings 变量设置
You can modify the run-time behavior of Readline by altering the values of variables in Readline using the set command within the init file. The syntax is simple:

通过使用 init 文件中的 set 命令修改 Readline 中变量的值，可以修改 Readline 的运行时行为。语法很简单:

set variable value
Here, for example, is how to change from the default Emacs-like key binding to use vi line editing commands:

例如，下面是如何从默认的类 emacs 键绑定改为使用 vi 行编辑命令:

set editing-mode vi
Variable names and values, where appropriate, are recognized without regard to case. Unrecognized variable names are ignored.

在适当的地方，可以识别变量名和值，而不考虑大小写。忽略无法识别的变量名。

Boolean variables (those that can be set to on or off) are set to on if the value is null or empty, on (case-insensitive), or 1. Any other value results in the variable being set to off.

如果值为 null 或空、 on (不区分大小写)或1，则布尔变量(可以设置为 on 或 off)将被设置为 on。任何其他值都会导致变量被设置为 off。

The bind -V command lists the current Readline variable names and values. See Bash Builtins.

Bind-v 命令列出当前 Readline 变量的名称和值。

A great deal of run-time behavior is changeable with the following variables.

许多运行时行为可以通过以下变量改变。

bell-style
Controls what happens when Readline wants to ring the terminal bell. If set to ‘none’, Readline never rings the bell. If set to ‘visible’, Readline uses a visible bell if one is available. If set to ‘audible’ (the default), Readline attempts to ring the terminal’s bell.

控制当 Readline 想要按响终端铃时所发生的事情。如果设置为“无” ，Readline 将不会响铃。如果设置为“ visible” ，Readline 将在可用时使用一个可见的铃铛。如果设置为“可听”(默认值) ，Readline 将尝试按响终端的铃声。

bind-tty-special-chars
If set to ‘on’ (the default), Readline attempts to bind the control characters treated specially by the kernel’s terminal driver to their Readline equivalents.

如果设置为“ on”(默认值) ，Readline 将尝试将内核终端驱动程序特别处理的控制字符绑定到等效的 Readline。

blink-matching-paren
If set to ‘on’, Readline attempts to briefly move the cursor to an opening parenthesis when a closing parenthesis is inserted. The default is ‘off’.

如果设置为“ on” ，则在插入闭括号时，Readline 会尝试将光标短暂地移动到开括号上。默认是关闭的。

colored-completion-prefix
If set to ‘on’, when listing completions, Readline displays the common prefix of the set of possible completions using a different color. The color definitions are taken from the value of the LS_COLORS environment variable. The default is ‘off’.

如果设置为“ on” ，则在列出完成时，Readline 将使用不同的颜色显示可能完成集的公共前缀。颜色定义取自于颜色环境变量的值。默认是关闭的。

colored-stats
If set to ‘on’, Readline displays possible completions using different colors to indicate their file type. The color definitions are taken from the value of the LS_COLORS environment variable. The default is ‘off’.

如果设置为“ on” ，Readline 将使用不同的颜色显示可能的完成情况，以指示其文件类型。颜色定义取自于颜色环境变量的值。默认是关闭的。

comment-begin
The string to insert at the beginning of the line when the insert-comment command is executed. The default value is "#".

执行 insert-comment 命令时要插入到行首的字符串。默认值是“ # ”。

completion-display-width
The number of screen columns used to display possible matches when performing completion. The value is ignored if it is less than 0 or greater than the terminal screen width. A value of 0 will cause matches to be displayed one per line. The default value is -1.

执行完成时用于显示可能匹配的屏幕列数。如果该值小于0或大于终端屏幕宽度，则忽略该值。值为0将导致每行显示一个匹配项。默认值是 -1。

completion-ignore-case
If set to ‘on’, Readline performs filename matching and completion in a case-insensitive fashion. The default value is ‘off’.

如果设置为“ on” ，Readline 将以不区分大小写的方式执行文件名匹配和完成。默认值为“ off”。

completion-map-case
If set to ‘on’, and completion-ignore-case is enabled, Readline treats hyphens (‘-’) and underscores (‘_’) as equivalent when performing case-insensitive filename matching and completion. The default value is ‘off’.

如果设置为‘ on’ ，并启用 completion-ignore-case，Readline 在执行不区分大小写的文件名匹配和完成时将连字符(‘-’)和下划线(‘ _’)视为等效。默认值为 off。

completion-prefix-display-length
The length in characters of the common prefix of a list of possible completions that is displayed without modification. When set to a value greater than zero, common prefixes longer than this value are replaced with an ellipsis when displaying possible completions.

未经修改显示的可能完成列表的公共前缀的字符长度。当设置为大于零的值时，在显示可能的完成时，长于此值的公共前缀将替换为省略号。

completion-query-items
The number of possible completions that determines when the user is asked whether the list of possibilities should be displayed. If the number of possible completions is greater than this value, Readline will ask the user whether or not he wishes to view them; otherwise, they are simply listed. This variable must be set to an integer value greater than or equal to 0. A negative value means Readline should never ask. The default limit is 100.

确定何时向用户询问是否应该显示可能性列表的可能完成数。如果可能的完成次数大于这个值，Readline 将询问用户是否希望查看它们; 否则，它们将被简单地列出。此变量必须设置为大于或等于0的整数值。负值意味着 Readline 不应该询问。默认限制是100。

convert-meta
If set to ‘on’, Readline will convert characters with the eighth bit set to an ASCII key sequence by stripping the eighth bit and prefixing an ESC character, converting them to a meta-prefixed key sequence. The default value is ‘on’, but will be set to ‘off’ if the locale is one that contains eight-bit characters.

如果设置为“打开” ，Readline 将通过删除第八位并在 ESC 字符前加上前缀，将第八位字符转换为一个带有元前缀的键序列，从而将其转换为一个 ASCII 键序列。默认值是“ on” ，但是如果区域设置是包含位字符的区域设置，则默认值将被设置为“ off”。

disable-completion
If set to ‘On’, Readline will inhibit word completion. Completion characters will be inserted into the line as if they had been mapped to self-insert. The default is ‘off’.

如果设置为“ On” ，Readline 将禁止单词完成。完成字符将插入到该行中，就像它们已经映射到自插入一样。默认是关闭的。

echo-control-characters
When set to ‘on’, on operating systems that indicate they support it, readline echoes a character corresponding to a signal generated from the keyboard. The default is ‘on’.

当设置为“打开”时，操作系统表明它们支持它，readline 回显一个与键盘产生的信号相对应的字符。默认设置为“ on”。

editing-mode
The editing-mode variable controls which default set of key bindings is used. By default, Readline starts up in Emacs editing mode, where the keystrokes are most similar to Emacs. This variable can be set to either ‘emacs’ or ‘vi’.

编辑模式变量控制使用默认的键绑定集。默认情况下，Readline 在 Emacs 编辑模式下启动，在这种模式下，按键操作与 Emacs 最为相似。这个变量可以设置为 emacs 或 vi。

emacs-mode-string
If the show-mode-in-prompt variable is enabled, this string is displayed immediately before the last line of the primary prompt when emacs editing mode is active. The value is expanded like a key binding, so the standard set of meta- and control prefixes and backslash escape sequences is available. Use the ‘\1’ and ‘\2’ escapes to begin and end sequences of non-printing characters, which can be used to embed a terminal control sequence into the mode string. The default is ‘@’.

如果启用了 show-mode-in-prompt 变量，则当 emacs 编辑模式处于活动状态时，此字符串将紧接在主提示的最后一行之前显示。该值像键绑定一样进行扩展，因此可以使用标准的 meta-and 控件前缀和反斜杠转义序列集。使用“1”和“2”转义来开始和结束非打印字符序列，这可用于将终端控制序列嵌入模式字符串。默认值是@。

enable-bracketed-paste
When set to ‘On’, Readline will configure the terminal in a way that will enable it to insert each paste into the editing buffer as a single string of characters, instead of treating each character as if it had been read from the keyboard. This can prevent pasted characters from being interpreted as editing commands. The default is ‘off’.

当设置为 On 时，Readline 将配置终端，使其能够将每个粘贴作为一个字符串插入编辑缓冲区，而不是像从键盘读取一样处理每个字符。这可以防止粘贴的字符被解释为编辑命令。默认是关闭的。

enable-keypad
When set to ‘on’, Readline will try to enable the application keypad when it is called. Some systems need this to enable the arrow keys. The default is ‘off’.

当设置为“ on”时，Readline 将尝试在调用应用程序时启用该应用程序键盘。有些系统需要这个来启用箭头键。默认是关闭的。

enable-meta-key
When set to ‘on’, Readline will try to enable any meta modifier key the terminal claims to support when it is called. On many terminals, the meta key is used to send eight-bit characters. The default is ‘on’.

当设置为‘ on’时，Readline 将尝试启用终端声称支持的任何元修饰键。在许多终端上，使用元键发送八位字符。默认设置为“ on”。

expand-tilde
If set to ‘on’, tilde expansion is performed when Readline attempts word completion. The default is ‘off’.

如果设置为“ on” ，则当 Readline 尝试单词完成时执行波浪线展开。默认值为“ off”。

history-preserve-point
If set to ‘on’, the history code attempts to place the point (the current cursor position) at the same location on each history line retrieved with previous-history or next-history. The default is ‘off’.

如果设置为“ on” ，历史代码将尝试将点(当前光标位置)放置在用以前历史记录或下一历史记录检索的每个历史记录行的同一位置。默认是关闭的。

history-size
Set the maximum number of history entries saved in the history list. If set to zero, any existing history entries are deleted and no new entries are saved. If set to a value less than zero, the number of history entries is not limited. By default, the number of history entries is not limited. If an attempt is made to set history-size to a non-numeric value, the maximum number of history entries will be set to 500.

设置历史记录列表中保存的历史记录项的最大数量。如果设置为零，则删除所有现有的历史记录项，并且不保存任何新记录项。如果设置为小于零的值，则不限制历史记录条目的数量。默认情况下，历史记录条目的数量不受限制。如果尝试将 history-size 设置为非数值，则历史记录条目的最大数量将设置为500。

horizontal-scroll-mode
This variable can be set to either ‘on’ or ‘off’. Setting it to ‘on’ means that the text of the lines being edited will scroll horizontally on a single screen line when they are longer than the width of the screen, instead of wrapping onto a new screen line. By default, this variable is set to ‘off’.

这个变量可以设置为“开”或“关”。将其设置为“ on”意味着被编辑行的文本在长于屏幕宽度时将水平滚动到一个屏幕行上，而不是环绕到新的屏幕行上。默认情况下，此变量设置为“ off”。

input-meta
If set to ‘on’, Readline will enable eight-bit input (it will not clear the eighth bit in the characters it reads), regardless of what the terminal claims it can support. The default value is ‘off’, but Readline will set it to ‘on’ if the locale contains eight-bit characters. The name meta-flag is a synonym for this variable.

如果设置为“ on” ，Readline 将启用八位输入(它不会清除它读取的字符中的第八位) ，不管终端声称它可以支持什么。默认值是“ off” ，但如果区域设置包含位字符，Readline 将把它设置为“ on”。Name meta-flag 是这个变量的同义词。

isearch-terminators
The string of characters that should terminate an incremental search without subsequently executing the character as a command (see Searching). If this variable has not been given a value, the characters ESC and C-J will terminate an incremental search.

应该终止增量搜索而不随后将该字符作为命令执行的字符串(请参阅搜索)。如果没有给这个变量赋值，字符 ESC 和 C-J 将终止增量搜索。

keymap
Sets Readline’s idea of the current keymap for key binding commands. Built-in keymap names are emacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move, vi-command, and vi-insert. vi is equivalent to vi-command (vi-move is also a synonym); emacs is equivalent to emacs-standard. Applications may add additional names. The default value is emacs. The value of the editing-mode variable also affects the default keymap.

设置 Readline 对当前键绑定命令的键图的想法。内置的 keymap 名称包括 emacs、 emacs-standard、 emacs-meta、 emacs-ctx、 vi、 vi-move、 vi-command 和 vi-insert。Vi 等同于 vi-command (vi-move 也是同义词) ; emacs 等同于 emacs-standard。应用程序可以添加其他名称。默认值是 emacs。编辑模式变量的值也会影响默认的 keymap。

keyseq-timeout
Specifies the duration Readline will wait for a character when reading an ambiguous key sequence (one that can form a complete key sequence using the input read so far, or can take additional input to complete a longer key sequence). If no input is received within the timeout, Readline will use the shorter but complete key sequence. Readline uses this value to determine whether or not input is available on the current input source (rl_instream by default). The value is specified in milliseconds, so a value of 1000 means that Readline will wait one second for additional input. If this variable is set to a value less than or equal to zero, or to a non-numeric value, Readline will wait until another key is pressed to decide which key sequence to complete. The default value is 500.

指定 Readline 在读取一个不明确的键序列时等待字符的持续时间(这个键序列可以使用到目前为止的输入读取形成一个完整的键序列，或者可以接受额外的输入来完成一个较长的键序列)。如果在超时内没有接收到输入，Readline 将使用较短但完整的键序列。Readline 使用这个值来确定当前输入源(默认为 rl _ instream)上的输入是否可用。该值是以毫秒为单位指定的，因此如果值为1000，Readline 将等待一秒钟以获得额外的输入。如果将此变量设置为小于或等于零的值或非数值，Readline 将等待，直到按下另一个键来决定完成哪个键序列。默认值是500。

mark-directories
If set to ‘on’, completed directory names have a slash appended. The default is ‘on’.

如果设置为“ on” ，则在已完成的目录名中添加斜杠。默认值为“ on”。

mark-modified-lines
This variable, when set to ‘on’, causes Readline to display an asterisk (‘*’) at the start of history lines which have been modified. This variable is ‘off’ by default.

这个变量设置为“ on”时，会导致 Readline 在修改过的历史记录行的开头显示星号(“ * ”)。默认情况下，这个变量是关闭的。

mark-symlinked-directories
If set to ‘on’, completed names which are symbolic links to directories have a slash appended (subject to the value of mark-directories). The default is ‘off’.

如果设置为“ on” ，则指向目录的符号链接中的完整名称将附加斜杠(以 mark-directories 的值为准)。默认是关闭的。

match-hidden-files
This variable, when set to ‘on’, causes Readline to match files whose names begin with a ‘.’ (hidden files) when performing filename completion. If set to ‘off’, the leading ‘.’ must be supplied by the user in the filename to be completed. This variable is ‘on’ by default.

当这个变量设置为“ on”时，使 Readline 匹配名称以“”开头的文件当执行文件名完成时，请使用。如果设置为“ off” ，则前导的“必须由用户在要完成的文件名中提供。默认情况下，这个变量是‘ on’。

menu-complete-display-prefix
If set to ‘on’, menu completion displays the common prefix of the list of possible completions (which may be empty) before cycling through the list. The default is ‘off’.

如果设置为“ on” ，菜单完成将在循环遍历列表之前显示可能完成列表的公共前缀(可能为空)。默认是关闭的。

output-meta
If set to ‘on’, Readline will display characters with the eighth bit set directly rather than as a meta-prefixed escape sequence. The default is ‘off’, but Readline will set it to ‘on’ if the locale contains eight-bit characters.

如果设置为“ on” ，Readline 将直接显示第八位的字符，而不是元前缀的转义序列。默认值是“ off” ，但如果区域设置包含位字符，Readline 会将其设置为“ on”。

page-completions
If set to ‘on’, Readline uses an internal more-like pager to display a screenful of possible completions at a time. This variable is ‘on’ by default.

如果设置为“ on” ，Readline 将使用一个类似于寻呼机的内部设置，一次显示一屏幕的可能完成情况。默认情况下，这个变量是‘ on’。

print-completions-horizontally
If set to ‘on’, Readline will display completions with matches sorted horizontally in alphabetical order, rather than down the screen. The default is ‘off’.

如果设置为‘ on’ ，Readline 将显示完成的匹配在字母顺序文件中水平排序，而不是在屏幕下方。默认是关闭的。

revert-all-at-newline
If set to ‘on’, Readline will undo all changes to history lines before returning when accept-line is executed. By default, history lines may be modified and retain individual undo lists across calls to readline. The default is ‘off’.

如果设置为“ on” ，Readline 将撤消对历史记录行的所有更改，然后在执行 accept-line 时返回。默认情况下，可以修改历史记录行，并保留跨调用的单个撤销列表以重新读取。默认是关闭的。

show-all-if-ambiguous
This alters the default behavior of the completion functions. If set to ‘on’, words which have more than one possible completion cause the matches to be listed immediately instead of ringing the bell. The default value is ‘off’.

这会改变补全函数的默认行为。如果设置为“ on” ，有多个可能完成的单词将导致立即列出匹配项，而不是按铃。默认值为 off。

show-all-if-unmodified
This alters the default behavior of the completion functions in a fashion similar to show-all-if-ambiguous. If set to ‘on’, words which have more than one possible completion without any possible partial completion (the possible completions don’t share a common prefix) cause the matches to be listed immediately instead of ringing the bell. The default value is ‘off’.

这将以类似于 show-all-if-暧昧的方式修改完成函数的默认行为。如果设置为“ on” ，有多个可能完成但没有任何可能部分完成的单词(可能完成的单词不共享一个共同的前缀)将导致立即列出匹配而不是按铃。默认值为 off。

show-mode-in-prompt
If set to ‘on’, add a string to the beginning of the prompt indicating the editing mode: emacs, vi command, or vi insertion. The mode strings are user-settable (e.g., emacs-mode-string). The default value is ‘off’.

如果设置为‘ on’ ，则在提示符的开头添加一个字符串，指示编辑模式: emacs、 vi 命令或 vi 插入。模式字符串是用户可设置的(例如，emacs-mode-string)。默认值为 off。

skip-completed-text
If set to ‘on’, this alters the default completion behavior when inserting a single match into the line. It’s only active when performing completion in the middle of a word. If enabled, readline does not insert characters from the completion that match characters after point in the word being completed, so portions of the word following the cursor are not duplicated. For instance, if this is enabled, attempting completion when the cursor is after the ‘e’ in ‘Makefile’ will result in ‘Makefile’ rather than ‘Makefilefile’, assuming there is a single possible completion. The default value is ‘off’.

如果设置为“ on” ，则在向行中插入一个匹配项时，将改变默认的补全行为。只有在一个单词的中间执行完成时，它才会被激活。如果启用，readline 将不插入完成时的字符，这些字符将匹配完成的单词中的一个又一个字符，因此光标后面的单词部分不会重复。例如，如果启用了这个选项，假设有一个可能的完成，那么当光标位于 Makefile 中的‘ e’之后时尝试完成将导致‘ Makefile’而不是‘ Makefilefile’。默认值为 off。

vi-cmd-mode-string
If the show-mode-in-prompt variable is enabled, this string is displayed immediately before the last line of the primary prompt when vi editing mode is active and in command mode. The value is expanded like a key binding, so the standard set of meta- and control prefixes and backslash escape sequences is available. Use the ‘\1’ and ‘\2’ escapes to begin and end sequences of non-printing characters, which can be used to embed a terminal control sequence into the mode string. The default is ‘(cmd)’.

如果启用了 show-mode-in-prompt 变量，则当 vi 编辑模式处于活动状态并处于命令模式时，此字符串将立即显示在主提示符的最后一行之前。该值像键绑定一样进行扩展，因此可以使用标准的 meta-and 控件前缀和反斜杠转义序列集。使用“1”和“2”转义来开始和结束非打印字符序列，这可用于将终端控制序列嵌入模式字符串。默认值是“(cmd)”。

vi-ins-mode-string
If the show-mode-in-prompt variable is enabled, this string is displayed immediately before the last line of the primary prompt when vi editing mode is active and in insertion mode. The value is expanded like a key binding, so the standard set of meta- and control prefixes and backslash escape sequences is available. Use the ‘\1’ and ‘\2’ escapes to begin and end sequences of non-printing characters, which can be used to embed a terminal control sequence into the mode string. The default is ‘(ins)’.

如果启用了 show-mode-in-prompt 变量，则当 vi 编辑模式处于活动状态并处于插入模式时，此字符串将立即显示在主提示符的最后一行之前。该值像键绑定一样进行扩展，因此可以使用标准的 meta-and 控件前缀和反斜杠转义序列集。使用“1”和“2”转义来开始和结束非打印字符序列，这可用于将终端控制序列嵌入模式字符串。默认值是“(ins)”。

visible-stats
If set to ‘on’, a character denoting a file’s type is appended to the filename when listing possible completions. The default is ‘off’.

如果设置为“ on” ，则在列出可能的完成时，文件名会附加一个表示文件类型的字符。默认是关闭的。

Key Bindings 密码匙绑定
The syntax for controlling key bindings in the init file is simple. First you need to find the name of the command that you want to change. The following sections contain tables of the command name, the default keybinding, if any, and a short description of what the command does.

控制 init 文件中的键绑定的语法很简单。首先，您需要找到要更改的命令的名称。以下部分包含命令名表、默认密钥绑定(如果有的话)以及命令的简短说明。

Once you know the name of the command, simply place on a line in the init file the name of the key you wish to bind the command to, a colon, and then the name of the command. There can be no space between the key name and the colon – that will be interpreted as part of the key name. The name of the key can be expressed in different ways, depending on what you find most comfortable.

一旦知道命令的名称，只需在 init 文件中的一行中放置要将命令绑定到的键的名称、冒号，然后是命令的名称。键名和冒号之间不能有空格——这将被解释为键名的一部分。钥匙的名字可以用不同的方式来表达，这取决于你觉得最舒服的是什么。

In addition to command names, readline allows keys to be bound to a string that is inserted when the key is pressed (a macro).

除了命令名之外，readline 还允许将键绑定到按键时插入的字符串(宏)。

The bind -p command displays Readline function names and bindings in a format that can put directly into an initialization file. See Bash Builtins.

Bind-p 命令以可以直接放入初始化文件的格式显示 Readline 函数名和绑定。参见 Bash Builtins。

keyname 键名: function-name 函数名 or  或macro 宏
keyname is the name of a key spelled out in English. For example:

Keyname 是以英文拼写的密码匙的名称，例如:

Control-u: universal-argument
Meta-Rubout: backward-kill-word
Control-o: "> output"
In the example above, C-u is bound to the function universal-argument, M-DEL is bound to the function backward-kill-word, and C-o is bound to run the macro expressed on the right hand side (that is, to insert the text ‘> output’ into the line).

在上面的例子中，C-u 被绑定到函数 universal-argument，M-DEL 被绑定到函数 backward-kill-word，C-o 被绑定到运行右边表示的宏(即在行中插入文本‘ > output’)。

A number of symbolic character names are recognized while processing this key binding syntax: DEL, ESC, ESCAPE, LFD, NEWLINE, RET, RETURN, RUBOUT, SPACE, SPC, and TAB.

在处理这个键绑定语法时，可以识别许多符号字符名: DEL、 ESC、 ESCAPE、 LFD、 NEWLINE、 RET、 RETURN、 RUBOUT、 SPACE、 SPC 和 TAB。

"keyseq": function-name 函数名 or  或macro 宏
keyseq differs from keyname above in that strings denoting an entire key sequence can be specified, by placing the key sequence in double quotes. Some GNU Emacs style key escapes can be used, as in the following example, but the special character names are not recognized.

Keyseq 与上面的 keyname 不同之处在于，可以通过将密钥序列放置在双引号中来指定表示整个密钥序列的字符串。可以使用一些 GNU Emacs 样式的键转义，如下面的示例所示，但是不能识别特殊的字符名称。

"\C-u": universal-argument
"\C-x\C-r": re-read-init-file
"\e[11~": "Function Key 1"
In the above example, C-u is again bound to the function universal-argument (just as it was in the first example), ‘C-x C-r’ is bound to the function re-read-init-file, and ‘ESC [ 1 1 ~’ is bound to insert the text ‘Function Key 1’.

在上面的例子中，C-u 再次绑定到函数泛参数(就像在第一个例子中一样) ，‘ C-x C-r’绑定到函数 re-read-init-file，‘ ESC [11 ~ ’绑定到插入文本‘ Function Key 1’。

The following GNU Emacs style escape sequences are available when specifying key sequences:

当指定键序列时，下面的 GNU Emacs 风格的转义序列可用:

\C-
control prefix

控制前缀

\M-
meta prefix

元前缀

\e
an escape character

转义字符

\\
backslash

反斜杠

\"
", a double quotation mark

” ，双引号

\'
', a single quote or apostrophe

’ ，一个单引号或撇号

In addition to the GNU Emacs style escape sequences, a second set of backslash escapes is available:

除了 GNU Emacs 风格的转义序列之外，还有一套反斜杠转义:

\a
alert (bell)

警报(铃)

\b
backspace

退格

\d
delete

删除

\f
form feed

模板进给

\n
newline

换行

\r
carriage return

回车

\t
horizontal tab

水平制动片

\v
vertical tab

垂直调整片

\nnn
the eight-bit character whose value is the octal value nnn (one to three digits)

值为八进制值 nnn (一到三位数)的八位字符

\xHH
the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)

八位字符，其值为十六进制值 HH (一个或两个十六进制数字)

When entering the text of a macro, single or double quotes must be used to indicate a macro definition. Unquoted text is assumed to be a function name. In the macro body, the backslash escapes described above are expanded. Backslash will quote any other character in the macro text, including ‘"’ and ‘'’. For example, the following binding will make ‘C-x \’ insert a single ‘\’ into the line:

在输入宏的文本时，必须使用单引号或双引号来指示宏定义。非引号文本假定为函数名。在宏主体中，上面描述的反斜杠逸出被展开。反斜杠将引用宏文本中的任何其他字符，包括“”和“”。例如，下面的绑定将使“ C-x”在行中插入一个单独的“” :

"\C-x\\": "\\"
Next: Sample Init File, Previous: Readline Init File Syntax, Up: Readline Init File   [Contents][Index]

下一步: 示例 Init 文件，上一步: Readline Init File Syntax，Up: Readline Init File [ Contents ][ Index ]

8.3.2 Conditional Init Constructs
8.3.2条件 Init 结构
Readline implements a facility similar in spirit to the conditional compilation features of the C preprocessor which allows key bindings and variable settings to be performed as the result of tests. There are four parser directives used.

Readline 实现了一个类似于 c 预处理器的条件编译特性的工具，它允许在测试结果中执行键绑定和变量设置。使用了四个解析器指令。

$if
The $if construct allows bindings to be made based on the editing mode, the terminal being used, or the application using Readline. The text of the test, after any comparison operator, extends to the end of the line; unless otherwise noted, no characters are required to isolate it.

$if 构造允许基于编辑模式、使用的终端或使用 Readline 的应用程序制作绑定。在任何比较运算符之后，测试的文本延伸到行的末尾; 除非另有说明，否则不需要任何字符来隔离它。

mode
The mode= form of the $if directive is used to test whether Readline is in emacs or vi mode. This may be used in conjunction with the ‘set keymap’ command, for instance, to set bindings in the emacs-standard and emacs-ctlx keymaps only if Readline is starting out in emacs mode.

使用 $if 指令的 mode = form 来测试 Readline 是处于 emacs 模式还是 vi 模式。这可以与“ set keymap”命令结合使用，例如，只有当 Readline 以 emacs 模式启动时，才可以在 emacs 标准和 emacs-ctlx keymaps 中设置绑定。

term
The term= form may be used to include terminal-specific key bindings, perhaps to bind the key sequences output by the terminal’s function keys. The word on the right side of the ‘=’ is tested against both the full name of the terminal and the portion of the terminal name before the first ‘-’. This allows sun to match both sun and sun-cmd, for instance.

Term = form 可用于包括终端特定的键绑定，也许用于绑定终端的函数键输出的键序列。“ = ”右侧的单词将根据终端的全名和终端名称的第一个“-”前面的部分进行测试。例如，这允许 sun 匹配 sun 和 sun-cmd。

version
The version test may be used to perform comparisons against specific Readline versions. The version expands to the current Readline version. The set of comparison operators includes ‘=’ (and ‘==’), ‘!=’, ‘<=’, ‘>=’, ‘<’, and ‘>’. The version number supplied on the right side of the operator consists of a major version number, an optional decimal point, and an optional minor version (e.g., ‘7.1’). If the minor version is omitted, it is assumed to be ‘0’. The operator may be separated from the string version and from the version number argument by whitespace. The following example sets a variable if the Readline version being used is 7.0 or newer:

版本测试可用于对特定的 Readline 版本执行比较。版本扩展到当前的 Readline 版本。比较运算符集包括‘ = ’(和‘ = = ’)、‘ ！= ’ ，’ < = ’ ，’ > = ’ ，’ < ’ ，’ > ’。操作符右侧提供的版本号包括一个主版本号、一个可选的小数点和一个可选的次版本号(例如，“7.1”)。如果省略了次要版本，则假定它是“0”。操作符可以通过空格与字符串版本和版本号参数分离。如果使用的 Readline 版本为7.0或更高版本，则下面的示例设置变量:

$if version >= 7.0
set show-mode-in-prompt on
$endif
application
The application construct is used to include application-specific settings. Each program using the Readline library sets the application name, and you can test for a particular value. This could be used to bind key sequences to functions useful for a specific program. For instance, the following command adds a key sequence that quotes the current or previous word in Bash:

应用程序构造用于包含特定于应用程序的设置。使用 Readline 库的每个程序都会设置应用程序名称，您可以测试特定的值。这可用于将键序列绑定到对特定程序有用的函数。例如，下面的命令添加一个键序列，引用 Bash 中的当前或前一个单词:

$if Bash
# Quote the current or previous word
"\C-xq": "\eb\"\ef\""
$endif
variable
The variable construct provides simple equality tests for Readline variables and values. The permitted comparison operators are ‘=’, ‘==’, and ‘!=’. The variable name must be separated from the comparison operator by whitespace; the operator may be separated from the value on the right hand side by whitespace. Both string and boolean variables may be tested. Boolean variables must be tested against the values on and off. The following example is equivalent to the mode=emacs test described above:

变量构造为 Readline 变量和值提供了简单的等式测试。允许的比较运算符是‘ = ’、‘ = = ’和‘ ！= = .变量名必须通过空格与比较运算符分隔; 运算符可以通过空格与右侧的值分隔。字符串和布尔变量都可以测试。布尔变量必须根据开启和关闭的值进行测试。下面的示例相当于上面描述的 mode = emacs 测试:

$if editing-mode == emacs
set show-mode-in-prompt on
$endif
$endif
This command, as seen in the previous example, terminates an $if command.

如前面的示例所示，这个命令将终止 $if 命令。

$else
Commands in this branch of the $if directive are executed if the test fails.

如果测试失败，则执行 $if 指令的这个分支中的命令。

$include
This directive takes a single filename as an argument and reads commands and bindings from that file. For example, the following directive reads from /etc/inputrc:

此指令以单个文件名作为参数，并从该文件读取命令和绑定。例如，下面的指令读取/etc/inputrc:

$include /etc/inputrc
Previous: Conditional Init Constructs, Up: Readline Init File   [Contents][Index]

上一页: 条件 Init 构造，向上: Readline Init File [ Contents ][ Index ]

8.3.3 Sample Init File
8.3.3示例 Init 文件
Here is an example of an inputrc file. This illustrates key binding, variable assignment, and conditional syntax.

下面是一个输入文件的例子，它演示了密钥绑定、变量赋值和条件语法。

# This file controls the behaviour of line input editing for
# programs that use the GNU Readline library.  Existing
# programs include FTP, Bash, and GDB.
#
# You can re-read the inputrc file with C-x C-r.
# Lines beginning with '#' are comments.
#
# First, include any system-wide bindings and variable
# assignments from /etc/Inputrc
$include /etc/Inputrc

#
# Set various bindings for emacs mode.

set editing-mode emacs 

$if mode=emacs

Meta-Control-h:	backward-kill-word	Text after the function name is ignored

#
# Arrow keys in keypad mode
#
#"\M-OD":        backward-char
#"\M-OC":        forward-char
#"\M-OA":        previous-history
#"\M-OB":        next-history
#
# Arrow keys in ANSI mode
#
"\M-[D":        backward-char
"\M-[C":        forward-char
"\M-[A":        previous-history
"\M-[B":        next-history
#
# Arrow keys in 8 bit keypad mode
#
#"\M-\C-OD":       backward-char
#"\M-\C-OC":       forward-char
#"\M-\C-OA":       previous-history
#"\M-\C-OB":       next-history
#
# Arrow keys in 8 bit ANSI mode
#
#"\M-\C-[D":       backward-char
#"\M-\C-[C":       forward-char
#"\M-\C-[A":       previous-history
#"\M-\C-[B":       next-history

C-q: quoted-insert

$endif

# An old-style binding.  This happens to be the default.
TAB: complete

# Macros that are convenient for shell interaction
$if Bash
# edit the path
"\C-xp": "PATH=${PATH}\e\C-e\C-a\ef\C-f"
# prepare to type a quoted word --
# insert open and close double quotes
# and move to just after the open quote
"\C-x\"": "\"\"\C-b"
# insert a backslash (testing backslash escapes
# in sequences and macros)
"\C-x\\": "\\"
# Quote the current or previous word
"\C-xq": "\eb\"\ef\""
# Add a binding to refresh the line, which is unbound
"\C-xr": redraw-current-line
# Edit variable on current line.
"\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
$endif

# use a visible bell if one is available
set bell-style visible

# don't strip characters to 7 bits when reading
set input-meta on

# allow iso-latin1 characters to be inserted rather
# than converted to prefix-meta sequences
set convert-meta off

# display characters with the eighth bit set directly
# rather than as meta-prefixed characters
set output-meta on

# if there are more than 150 possible completions for
# a word, ask the user if he wants to see all of them
set completion-query-items 150

# For FTP
$if Ftp
"\C-xg": "get \M-?"
"\C-xt": "put \M-?"
"\M-.": yank-last-arg
$endif
Next: Readline vi Mode, Previous: Readline Init File, Up: Command Line Editing   [Contents][Index]

下一步: Readline vi Mode，Previous: Readline Init File，Up: Command Line Editing [ Contents ][ Index ]

8.4 Bindable Readline Commands
8.4可绑定的可读行命令
• Commands For Moving 移动命令:	  	Moving about the line. 在队伍里走来走去
• Commands For History 历史记录命令:	  	Getting at previous lines. 获得前面的路线
• Commands For Text 文本命令:	  	Commands for changing text. 更改文本的命令
• Commands For Killing 杀戮指令:	  	Commands for killing and yanking. 杀戮和拉扯的命令
• Numeric Arguments 数字参数:	  	Specifying numeric arguments, repeat counts. 指定数值参数，重复计数
• Commands For Completion 完成命令:	  	Getting Readline to do the typing for you. 让 Readline 帮你打字
• Keyboard Macros 键盘宏:	  	Saving and re-executing typed characters 保存和重新执行类型化字符
• Miscellaneous Commands 杂项命令:	  	Other miscellaneous commands. 其他杂项命令
This section describes Readline commands that may be bound to key sequences. You can list your key bindings by executing bind -P or, for a more terse format, suitable for an inputrc file, bind -p. (See Bash Builtins.) Command names without an accompanying key sequence are unbound by default.

本节描述可能绑定到键序列的 Readline 命令。您可以通过执行 bind-p 来列出键绑定，或者，对于更简洁的格式，适合于 inputrc 文件 bind-p (参见 Bash Builtins.)缺省情况下，没有附带键序列的命令名称是不绑定的。

In the following descriptions, point refers to the current cursor position, and mark refers to a cursor position saved by the set-mark command. The text between the point and mark is referred to as the region.

在下面的描述中，point 指的是当前的光标位置，mark 指的是由 set-mark 命令保存的光标位置。点和标记之间的文本称为区域。

Next: Commands For History, Up: Bindable Readline Commands   [Contents][Index]

下一步: 历史命令，向上: 可绑定的读行命令[目录][索引]

8.4.1 Commands For Moving
8.4.1移动命令
beginning-of-line (C-a)
Move to the start of the current line.

移动到当前行的开头。

end-of-line (C-e)
Move to the end of the line.

走到队伍的末尾。

forward-char (C-f)
Move forward a character.

向前移动一个字符。

backward-char (C-b)
Move back a character.

向后移动一个字符。

forward-word (M-f)
Move forward to the end of the next word. Words are composed of letters and digits.

向前移到下一个单词的末尾。单词是由字母和数字组成的。

backward-word (M-b)
Move back to the start of the current or previous word. Words are composed of letters and digits.

回到当前或前一个单词的开头。单词由字母和数字组成。

shell-forward-word ()
Move forward to the end of the next word. Words are delimited by non-quoted shell metacharacters.

向前移到下一个单词的末尾。这些单词由非引号的 shell 元字符分隔。

shell-backward-word ()
Move back to the start of the current or previous word. Words are delimited by non-quoted shell metacharacters.

返回到当前或前一个单词的开头。单词由非引号的 shell 元字符分隔。

previous-screen-line ()
Attempt to move point to the same physical screen column on the previous physical screen line. This will not have the desired effect if the current Readline line does not take up more than one physical line or if point is not greater than the length of the prompt plus the screen width.

尝试将点移动到前一物理屏幕行上的同一物理屏幕列。如果当前的 Readline 不占用多于一条物理线，或者如果 point 不大于提示符的长度加上屏幕宽度，这将不会产生预期的效果。

next-screen-line ()
Attempt to move point to the same physical screen column on the next physical screen line. This will not have the desired effect if the current Readline line does not take up more than one physical line or if the length of the current Readline line is not greater than the length of the prompt plus the screen width.

尝试将点移动到下一个物理屏幕行上的同一物理屏幕列。如果当前的 Readline 不占用多个物理行，或者当前 Readline 的长度不大于提示符的长度加上屏幕宽度，那么这将不会产生预期的效果。

clear-screen (C-l)
Clear the screen and redraw the current line, leaving the current line at the top of the screen.

清除屏幕并重新绘制当前线条，将当前线条保留在屏幕顶部。

redraw-current-line ()
Refresh the current line. By default, this is unbound.

刷新当前行。默认情况下，这是未绑定的。

Next: Commands For Text, Previous: Commands For Moving, Up: Bindable Readline Commands   [Contents][Index]

下一步: 文本命令，上一步: 移动命令，向上: 可绑定的读行命令[目录][索引]

8.4.2 Commands For Manipulating The History
8.4.2操作历史记录的命令
accept-line (Newline or Return)
Accept the line regardless of where the cursor is. If this line is non-empty, add it to the history list according to the setting of the HISTCONTROL and HISTIGNORE variables. If this line is a modified history line, then restore the history line to its original state.

接受该行，而不管光标在哪里。如果此行非空，根据 HISTCONTROL 和 histigoree 变量的设置将其添加到历史列表中。如果此行是经过修改的历史记录行，则将历史记录行还原到其原始状态。

previous-history (C-p)
Move ‘back’ through the history list, fetching the previous command.

在历史记录列表中移动‘ back’ ，获取前面的命令。

next-history (C-n)
Move ‘forward’ through the history list, fetching the next command.

在历史列表中向前移动，获取下一个命令。

beginning-of-history (M-<)
Move to the first line in the history.

移动到历史的第一行。

end-of-history (M->)
Move to the end of the input history, i.e., the line currently being entered.

移动到输入历史记录的末尾，即当前输入的行。

reverse-search-history (C-r)
Search backward starting at the current line and moving ‘up’ through the history as necessary. This is an incremental search.

从当前行开始向后搜索，必要时在历史记录中向上搜索。这是一个增量搜索。

forward-search-history (C-s)
Search forward starting at the current line and moving ‘down’ through the history as necessary. This is an incremental search.

从当前行开始向前搜索，然后根据需要在历史记录中向下搜索。这是一个渐进式搜索。

non-incremental-reverse-search-history (M-p)
Search backward starting at the current line and moving ‘up’ through the history as necessary using a non-incremental search for a string supplied by the user. The search string may match anywhere in a history line.

使用用户提供的字符串进行非增量式搜索，从当前行开始向后搜索，必要时在历史记录中向上搜索。搜索字符串可以匹配历史行中的任何位置。

non-incremental-forward-search-history (M-n)
Search forward starting at the current line and moving ‘down’ through the history as necessary using a non-incremental search for a string supplied by the user. The search string may match anywhere in a history line.

从当前行开始向前搜索，必要时使用用户提供的字符串的非增量搜索在历史记录中向下搜索。搜索字符串可以匹配历史行中的任何位置。

history-search-forward ()
Search forward through the history for the string of characters between the start of the current line and the point. The search string must match at the beginning of a history line. This is a non-incremental search. By default, this command is unbound.

在历史记录中向前搜索当前行的起始点和点之间的字符串。搜索字符串必须匹配历史记录行的开头。这是一个非增量式搜索。默认情况下，此命令是未绑定的。

history-search-backward ()
Search backward through the history for the string of characters between the start of the current line and the point. The search string must match at the beginning of a history line. This is a non-incremental search. By default, this command is unbound.

在历史记录中向后搜索当前行的起点和点之间的字符串。搜索字符串必须匹配历史记录行的开头。这是一个非增量式搜索。默认情况下，此命令是未绑定的。

history-substring-search-forward ()
Search forward through the history for the string of characters between the start of the current line and the point. The search string may match anywhere in a history line. This is a non-incremental search. By default, this command is unbound.

在历史记录中向前搜索当前行的起始点和点之间的字符串。搜索字符串可以匹配历史行中的任何位置。这是一个非增量式搜索。默认情况下，此命令是未绑定的。

history-substring-search-backward ()
Search backward through the history for the string of characters between the start of the current line and the point. The search string may match anywhere in a history line. This is a non-incremental search. By default, this command is unbound.

在历史记录中向后搜索当前行的起点和点之间的字符串。搜索字符串可以匹配历史行中的任何位置。这是一个非增量式搜索。默认情况下，此命令是未绑定的。

yank-nth-arg (M-C-y)
Insert the first argument to the previous command (usually the second word on the previous line) at point. With an argument n, insert the nth word from the previous command (the words in the previous command begin with word 0). A negative argument inserts the nth word from the end of the previous command. Once the argument n is computed, the argument is extracted as if the ‘!n’ history expansion had been specified.

将第一个参数插入到前一个命令中(通常是前一行的第二个单词)。使用参数 n，插入前一个命令中的第 n 个单词(前一个命令中的单词以单词0开头)。否定参数从前一个命令的结尾插入第 n 个单词。一旦参数 n 被计算出来，参数就会被提取出来，就像‘ ！历史扩展已经被明确规定。

yank-last-arg (M-. or M-_)
Insert last argument to the previous command (the last word of the previous history entry). With a numeric argument, behave exactly like yank-nth-arg. Successive calls to yank-last-arg move back through the history list, inserting the last word (or the word specified by the argument to the first call) of each line in turn. Any numeric argument supplied to these successive calls determines the direction to move through the history. A negative argument switches the direction through the history (back or forward). The history expansion facilities are used to extract the last argument, as if the ‘!$’ history expansion had been specified.

将最后一个参数插入到前一个命令(前一个历史记录条目的最后一个单词)。使用数值参数，其行为完全类似于 yank-nth-arg。连续调用 yank-last-arg 返回历史列表，依次插入每一行的最后一个单词(或参数指定的单词)。为这些连续调用提供的任何数值参数都确定在历史记录中移动的方向。否定参数通过历史切换方向(后退或前进)。历史扩展工具用于提取最后一个参数，就像‘ ！“ $’历史扩展已指定。

Next: Commands For Killing, Previous: Commands For History, Up: Bindable Readline Commands   [Contents][Index]

下一步: 杀戮命令，上一步: 历史命令，向上: 可绑定的读行命令[目录][索引]

8.4.3 Commands For Changing Text
8.4.3改变文本的命令
end-of-file (usually C-d)
The character indicating end-of-file as set, for example, by stty. If this character is read when there are no characters on the line, and point is at the beginning of the line, Readline interprets it as the end of input and returns EOF.

表示文件结束的字符，例如，以 stty 表示。如果在行上没有字符时读取这个字符，并且点在行的开头，Readline 将其解释为输入的结束，并返回 EOF。

delete-char (C-d)
Delete the character at point. If this function is bound to the same character as the tty EOF character, as C-d commonly is, see above for the effects.

在某一点删除字符。如果这个函数与 tty EOF 字符绑定到相同的字符(通常是 C-d) ，请参见上面的效果。

backward-delete-char (Rubout)
Delete the character behind the cursor. A numeric argument means to kill the characters instead of deleting them.

删除光标后面的字符。数字参数意味着删除字符而不是删除它们。

forward-backward-delete-char ()
Delete the character under the cursor, unless the cursor is at the end of the line, in which case the character behind the cursor is deleted. By default, this is not bound to a key.

删除光标下面的字符，除非光标位于行尾，否则将删除光标后面的字符。默认情况下，这不绑定到密钥。

quoted-insert (C-q or C-v)
Add the next character typed to the line verbatim. This is how to insert key sequences like C-q, for example.

逐字添加输入到行中的下一个字符。例如，这是如何插入键序列(如 C-q)。

self-insert (a, b, A, 1, !, …)
Insert yourself.

插入你自己。

bracketed-paste-begin ()
This function is intended to be bound to the "bracketed paste" escape sequence sent by some terminals, and such a binding is assigned by default. It allows Readline to insert the pasted text as a single unit without treating each character as if it had been read from the keyboard. The characters are inserted as if each one was bound to self-insert instead of executing any editing commands.

此函数旨在绑定到某些终端发送的“括号内的粘贴”转义序列，默认情况下会分配这样的绑定。它允许 Readline 将粘贴的文本作为单个单元插入，而不会将每个字符视为从键盘上读取的字符。插入字符时，仿佛每个字符都被绑定到自插入，而不是执行任何编辑命令。

transpose-chars (C-t)
Drag the character before the cursor forward over the character at the cursor, moving the cursor forward as well. If the insertion point is at the end of the line, then this transposes the last two characters of the line. Negative arguments have no effect.

将光标前面的字符拖到光标前面的字符上，同时向前移动光标。如果插入点位于该行的末尾，那么这将转置该行的最后两个字符。否定的论点是没有效果的。

transpose-words (M-t)
Drag the word before point past the word after point, moving point past that word as well. If the insertion point is at the end of the line, this transposes the last two words on the line.

将单词前面的点拖过单词后面的点，同时移动单词前面的点。如果插入点位于该行的末尾，则将该行上的最后两个单词移位。

upcase-word (M-u)
Uppercase the current (or following) word. With a negative argument, uppercase the previous word, but do not move the cursor.

将当前(或后面)单词大写。用否定参数，将前一个单词大写，但不移动光标。

downcase-word (M-l)
Lowercase the current (or following) word. With a negative argument, lowercase the previous word, but do not move the cursor.

小写当前(或后面)单词。用否定参数，小写前一个单词，但不移动光标。

capitalize-word (M-c)
Capitalize the current (or following) word. With a negative argument, capitalize the previous word, but do not move the cursor.

将当前(或后面)单词大写。参数为负数时，将前一个单词大写，但不移动光标。

overwrite-mode ()
Toggle overwrite mode. With an explicit positive numeric argument, switches to overwrite mode. With an explicit non-positive numeric argument, switches to insert mode. This command affects only emacs mode; vi mode does overwrite differently. Each call to readline() starts in insert mode.

切换覆盖模式。使用显式的正数值参数，切换到覆盖模式。使用显式的非正数数值参数，切换到插入模式。此命令只影响 emacs 模式; vi 模式以不同的方式覆盖。对 readline ()的每个调用都以插入模式启动。

In overwrite mode, characters bound to self-insert replace the text at point rather than pushing the text to the right. Characters bound to backward-delete-char replace the character before point with a space.

在覆盖模式下，绑定到自插入的字符将替换点处的文本，而不是将文本向右推。绑定到反向删除字符的字符将前面的字符替换为空格。

By default, this command is unbound.

默认情况下，此命令是未绑定的。

Next: Numeric Arguments, Previous: Commands For Text, Up: Bindable Readline Commands   [Contents][Index]

下一步: 数字参数，上一步: 文本的命令，向上: 可绑定的读行命令[目录][索引]

8.4.4 Killing And Yanking
8.4.4杀戮与拉扯
kill-line (C-k)
Kill the text from point to the end of the line.

删除从点到行尾的文本。

backward-kill-line (C-x Rubout)
Kill backward from the cursor to the beginning of the current line.

从光标向后杀死当前行的开头。

unix-line-discard (C-u)
Kill backward from the cursor to the beginning of the current line.

从光标向后杀死当前行的开头。

kill-whole-line ()
Kill all characters on the current line, no matter where point is. By default, this is unbound.

杀死当前行上的所有字符，不管点在哪里。默认情况下，这是未绑定的。

kill-word (M-d)
Kill from point to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as forward-word.

杀死从点到结束的当前单词，或如果之间的话，到结束的下一个单词。词的边界和前进词是一样的。

backward-kill-word (M-DEL)
Kill the word behind point. Word boundaries are the same as backward-word.

关闭后面的单词。单词边界和后面的单词是一样的。

shell-kill-word ()
Kill from point to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as shell-forward-word.

杀死从点到结束的当前单词，或如果之间的话，到结束的下一个单词。单词边界与 shell-forward-Word 相同。

shell-backward-kill-word ()
Kill the word behind point. Word boundaries are the same as shell-backward-word.

关闭单词后面的点。单词边界和 shell-backward-Word 是一样的。

unix-word-rubout (C-w)
Kill the word behind point, using white space as a word boundary. The killed text is saved on the kill-ring.

杀死后面的单词，使用空格作为单词边界。杀死的文本保存在杀死环上。

unix-filename-rubout ()
Kill the word behind point, using white space and the slash character as the word boundaries. The killed text is saved on the kill-ring.

删除 point 后面的单词，使用空格和斜杠作为单词边界。被杀死的文本保存在杀死环上。

delete-horizontal-space ()
Delete all spaces and tabs around point. By default, this is unbound.

删除点周围的所有空格和制表符。默认情况下，这是未绑定的。

kill-region ()
Kill the text in the current region. By default, this command is unbound.

删除当前区域中的文本。默认情况下，此命令是未绑定的。

copy-region-as-kill ()
Copy the text in the region to the kill buffer, so it can be yanked right away. By default, this command is unbound.

将该区域中的文本复制到杀死缓冲区，以便可以立即将其提取。默认情况下，此命令是未绑定的。

copy-backward-word ()
Copy the word before point to the kill buffer. The word boundaries are the same as backward-word. By default, this command is unbound.

复制指向终止缓冲区之前的单词。这个词的边界和后向词是一样的。默认情况下，此命令是未绑定的。

copy-forward-word ()
Copy the word following point to the kill buffer. The word boundaries are the same as forward-word. By default, this command is unbound.

将下面的单词复制到 kill buffer。单词边界与前进单词相同。默认情况下，此命令是未绑定的。

yank (C-y)
Yank the top of the kill ring into the buffer at point.

在某一点将杀伤环顶部拉入缓冲区。

yank-pop (M-y)
Rotate the kill-ring, and yank the new top. You can only do this if the prior command is yank or yank-pop.

旋转杀伤环，并拉动新的顶部。只有在前面的命令是 yank-pop 或者 yank-pop 时，才可以这样做。

Next: Commands For Completion, Previous: Commands For Killing, Up: Bindable Readline Commands   [Contents][Index]

下一步: 完成命令，上一步: 杀死命令，向上: 可绑定的读行命令[目录][索引]

8.4.5 Specifying Numeric Arguments
8.4.5指定数字参数
digit-argument (M-0, M-1, … M--)
Add this digit to the argument already accumulating, or start a new argument. M-- starts a negative argument.

将这个数字添加到已经累积的参数中，或者开始一个新的参数。

universal-argument ()
This is another way to specify an argument. If this command is followed by one or more digits, optionally with a leading minus sign, those digits define the argument. If the command is followed by digits, executing universal-argument again ends the numeric argument, but is otherwise ignored. As a special case, if this command is immediately followed by a character that is neither a digit nor minus sign, the argument count for the next command is multiplied by four. The argument count is initially one, so executing this function the first time makes the argument count four, a second time makes the argument count sixteen, and so on. By default, this is not bound to a key.

这是指定参数的另一种方式。如果这个命令后面跟着一个或多个数字，可以选择带前导减号，这些数字定义参数。如果命令后面跟着数字，则执行 universal-argument 将再次结束数字参数，但是否则将被忽略。作为一种特殊情况，如果这个命令后面紧接着一个既不是数字也不是减号的字符，那么下一个命令的参数计数将乘以四。参数计数最初是1，所以第一次执行这个函数使参数计数为4，第二次使参数计数为十六，以此类推。默认情况下，这不绑定到密钥。

Next: Keyboard Macros, Previous: Numeric Arguments, Up: Bindable Readline Commands   [Contents][Index]

下一步: 键盘宏，上一步: 数字参数，向上: 可绑定的读行命令[目录][索引]

8.4.6 Letting Readline Type For You
8.4.6为你设置读行类型
complete (TAB)
Attempt to perform completion on the text before point. The actual completion performed is application-specific. Bash attempts completion treating the text as a variable (if the text begins with ‘$’), username (if the text begins with ‘~’), hostname (if the text begins with ‘@’), or command (including aliases and functions) in turn. If none of these produces a match, filename completion is attempted.

尝试在点之前完成文本。实际执行的完成是特定于应用程序的。Bash 尝试将文本视为变量(如果文本以“ $”开头)、用户名(如果文本以“ ~ ”开头)、主机名(如果文本以“@”开头)或命令(包括别名和函数)。如果没有匹配，则尝试文件名补全。

possible-completions (M-?)
List the possible completions of the text before point. When displaying completions, Readline sets the number of columns used for display to the value of completion-display-width, the value of the environment variable COLUMNS, or the screen width, in that order.

在点之前列出文本的可能完成情况。当显示完成时，Readline 将用于显示的列数设置为 completion-display-width 值、环境变量列值或屏幕宽度，顺序如下。

insert-completions (M-*)
Insert all completions of the text before point that would have been generated by possible-completions.

在可能完成的点之前插入案文的所有完成部分。

menu-complete ()
Similar to complete, but replaces the word to be completed with a single match from the list of possible completions. Repeated execution of menu-complete steps through the list of possible completions, inserting each match in turn. At the end of the list of completions, the bell is rung (subject to the setting of bell-style) and the original text is restored. An argument of n moves n positions forward in the list of matches; a negative argument may be used to move backward through the list. This command is intended to be bound to TAB, but is unbound by default.

与完成类似，但是将要完成的单词替换为可能完成列表中的单个匹配项。通过可能完成的列表重复执行菜单完成步骤，依次插入每个匹配项。在完成列表的末尾，铃声响起(根据铃声样式的设置)并恢复原始文本。在匹配列表中向前移动 n 个位置的参数; 可以使用负参数在列表中向后移动。此命令旨在绑定到 TAB，但默认情况下不绑定。

menu-complete-backward ()
Identical to menu-complete, but moves backward through the list of possible completions, as if menu-complete had been given a negative argument.

与菜单完成相同，但是在可能完成的列表中向后移动，就好像菜单完成被赋予了一个负参数。

delete-char-or-list ()
Deletes the character under the cursor if not at the beginning or end of the line (like delete-char). If at the end of the line, behaves identically to possible-completions. This command is unbound by default.

如果不在行首或行尾，则删除光标下的字符(如 delete-char)。如果在行尾，则行为与可能的-完成相同。默认情况下，此命令是未绑定的。

complete-filename (M-/)
Attempt filename completion on the text before point.

在点之前尝试文件名补全。

possible-filename-completions (C-x /)
List the possible completions of the text before point, treating it as a filename.

在点之前列出文本的可能完成情况，并将其作为文件名处理。

complete-username (M-~)
Attempt completion on the text before point, treating it as a username.

尝试在点之前完成文本，将其视为用户名。

possible-username-completions (C-x ~)
List the possible completions of the text before point, treating it as a username.

在点之前列出文本的可能完成部分，将其视为用户名。

complete-variable (M-$)
Attempt completion on the text before point, treating it as a shell variable.

尝试在点之前完成文本，将其视为 shell 变量。

possible-variable-completions (C-x $)
List the possible completions of the text before point, treating it as a shell variable.

在 point 之前列出文本的可能完成部分，将其视为 shell 变量。

complete-hostname (M-@)
Attempt completion on the text before point, treating it as a hostname.

尝试在点之前完成文本，将其视为主机名。

possible-hostname-completions (C-x @)
List the possible completions of the text before point, treating it as a hostname.

在点之前列出文本的可能完成情况，将其作为主机名处理。

complete-command (M-!)
Attempt completion on the text before point, treating it as a command name. Command completion attempts to match the text against aliases, reserved words, shell functions, shell builtins, and finally executable filenames, in that order.

尝试在点之前完成文本，将其视为命令名。命令补全尝试将文本与别名、保留字、 shell 函数、 shell 内置语言以及最终可执行文件名按照这个顺序进行匹配。

possible-command-completions (C-x !)
List the possible completions of the text before point, treating it as a command name.

在 point 之前列出文本的可能完成部分，将其视为命令名。

dynamic-complete-history (M-TAB)
Attempt completion on the text before point, comparing the text against lines from the history list for possible completion matches.

尝试在点之前完成文本，将文本与历史列表中的行进行比较，以便找到可能的完成匹配。

dabbrev-expand ()
Attempt menu completion on the text before point, comparing the text against lines from the history list for possible completion matches.

尝试在点之前完成文本菜单，将文本与历史列表中的行进行比较，以便找到可能的完成匹配。

complete-into-braces (M-{)
Perform filename completion and insert the list of possible completions enclosed within braces so the list is available to the shell (see Brace Expansion).

执行文件名完成，并插入大括号中包含的可能完成的列表，以便该列表对 shell 可用(请参阅布雷斯扩展)。

Next: Miscellaneous Commands, Previous: Commands For Completion, Up: Bindable Readline Commands   [Contents][Index]

下一步: 杂项命令，上一步: 完成命令，向上: 可绑定的读行命令[目录][索引]

8.4.7 Keyboard Macros
8.4.7键盘宏
start-kbd-macro (C-x ()
Begin saving the characters typed into the current keyboard macro.

开始保存键入当前键盘宏的字符。

end-kbd-macro (C-x ))
Stop saving the characters typed into the current keyboard macro and save the definition.

停止保存键入当前键盘宏的字符并保存定义。

call-last-kbd-macro (C-x e)
Re-execute the last keyboard macro defined, by making the characters in the macro appear as if typed at the keyboard.

重新执行最后定义的键盘宏，使宏中的字符看起来像是在键盘上键入的。

print-last-kbd-macro ()
Print the last keboard macro defined in a format suitable for the inputrc file.

以适合于输入文件的格式打印最后一个 keboard 宏。

Previous: Keyboard Macros, Up: Bindable Readline Commands   [Contents][Index]

上一页: 键盘宏，向上: 可绑定的读行命令[目录][索引]

8.4.8 Some Miscellaneous Commands
8.4.8一些其他的命令
re-read-init-file (C-x C-r)
Read in the contents of the inputrc file, and incorporate any bindings or variable assignments found there.

读取 inputrc 文件的内容，并合并在那里找到的任何绑定或变量赋值。

abort (C-g)
Abort the current editing command and ring the terminal’s bell (subject to the setting of bell-style).

终止当前的编辑命令并按响终端的铃(视铃样式的设置而定)。

do-lowercase-version (M-A, M-B, M-x, …)
If the metafied character x is upper case, run the command that is bound to the corresponding metafied lower case character. The behavior is undefined if x is already lower case.

如果元化字符 x 是大写，则运行绑定到相应元化小写字符的命令。如果 x 已经是小写，则行为是未定义的。

prefix-meta (ESC)
Metafy the next character typed. This is for keyboards without a meta key. Typing ‘ESC f’ is equivalent to typing M-f.

元化输入的下一个字符。这是为没有元键的键盘设计的。输入‘ ESC f’等同于输入 M-f。

undo (C-_ or C-x C-u)
Incremental undo, separately remembered for each line.

增量撤销，为每一行分别记住。

revert-line (M-r)
Undo all changes made to this line. This is like executing the undo command enough times to get back to the beginning.

撤消对此行所做的所有更改。这就好比执行撤销命令足够多次才能回到起点。

tilde-expand (M-&)
Perform tilde expansion on the current word.

对当前单词执行波浪线展开。

set-mark (C-@)
Set the mark to the point. If a numeric argument is supplied, the mark is set to that position.

将标记设置为该点。如果提供了数值参数，则将标记设置为该位置。

exchange-point-and-mark (C-x C-x)
Swap the point with the mark. The current cursor position is set to the saved position, and the old cursor position is saved as the mark.

把这一点和标记交换。将当前光标位置设置为保存的位置，并将旧光标位置保存为标记。

character-search (C-])
A character is read and point is moved to the next occurrence of that character. A negative count searches for previous occurrences.

读取一个字符并将点移动到该字符的下一个出现位置。负计数搜索以前出现的情况。

character-search-backward (M-C-])
A character is read and point is moved to the previous occurrence of that character. A negative count searches for subsequent occurrences.

读取一个字符并将点移动到该字符的前一个出现位置。负计数搜索后续出现的情况。

skip-csi-sequence ()
Read enough characters to consume a multi-key sequence such as those defined for keys like Home and End. Such sequences begin with a Control Sequence Indicator (CSI), usually ESC-[. If this sequence is bound to "\e[", keys producing such sequences will have no effect unless explicitly bound to a readline command, instead of inserting stray characters into the editing buffer. This is unbound by default, but usually bound to ESC-[.

读取足够的字符来使用多键序列，如为键(如 Home 和 End)定义的字符序列。这种序列以控制序列指示器(CSI)开始，通常是 ESC-[。如果这个序列绑定到“ e [” ，那么产生这种序列的键将没有任何效果，除非显式地绑定到 readline 命令，而不是将游离字符插入编辑缓冲区。这在默认情况下是未绑定的，但通常绑定到 ESC-[。

insert-comment (M-#)
Without a numeric argument, the value of the comment-begin variable is inserted at the beginning of the current line. If a numeric argument is supplied, this command acts as a toggle: if the characters at the beginning of the line do not match the value of comment-begin, the value is inserted, otherwise the characters in comment-begin are deleted from the beginning of the line. In either case, the line is accepted as if a newline had been typed. The default value of comment-begin causes this command to make the current line a shell comment. If a numeric argument causes the comment character to be removed, the line will be executed by the shell.

如果没有数值参数，则在当前行的开头插入 comment-begin 变量的值。如果提供了一个数字参数，这个命令将起到切换的作用: 如果行首的字符与 comment-begin 的值不匹配，则插入该值，否则 comment-begin 中的字符将从行首删除。无论哪种情况，这一行都会被接受，就像输入了换行符一样。Comment-begin 的默认值使这个命令使当前行成为 shell 注释。如果一个数值参数导致注释字符被删除，那么这一行将由 shell 执行。

dump-functions ()
Print all of the functions and their key bindings to the Readline output stream. If a numeric argument is supplied, the output is formatted in such a way that it can be made part of an inputrc file. This command is unbound by default.

将所有函数及其键绑定打印到 Readline 输出流。如果提供了数值参数，则输出的格式设置为可以将其作为输入文件的一部分。默认情况下，此命令是未绑定的。

dump-variables ()
Print all of the settable variables and their values to the Readline output stream. If a numeric argument is supplied, the output is formatted in such a way that it can be made part of an inputrc file. This command is unbound by default.

将所有可设置的变量及其值打印到 Readline 输出流。如果提供了数值参数，则输出的格式设置为可以将其作为输入文件的一部分。默认情况下，此命令是未绑定的。

dump-macros ()
Print all of the Readline key sequences bound to macros and the strings they output. If a numeric argument is supplied, the output is formatted in such a way that it can be made part of an inputrc file. This command is unbound by default.

打印绑定到宏的所有 Readline 键序列及其输出的字符串。如果提供了数值参数，则输出的格式设置为可以将其作为输入文件的一部分。默认情况下，此命令是未绑定的。

glob-complete-word (M-g)
The word before point is treated as a pattern for pathname expansion, with an asterisk implicitly appended. This pattern is used to generate a list of matching file names for possible completions.

Point 之前的单词被视为路径名展开的模式，并隐式附加了星号。此模式用于为可能的完成生成匹配的文件名列表。

glob-expand-word (C-x *)
The word before point is treated as a pattern for pathname expansion, and the list of matching file names is inserted, replacing the word. If a numeric argument is supplied, a ‘*’ is appended before pathname expansion.

Point 之前的单词被视为路径名展开的模式，并插入匹配的文件名列表，替换单词。如果提供了数值参数，则在路径名展开之前附加一个‘ * ’。

glob-list-expansions (C-x g)
The list of expansions that would have been generated by glob-expand-word is displayed, and the line is redrawn. If a numeric argument is supplied, a ‘*’ is appended before pathname expansion.

将显示由 glob-expand-word 生成的扩展列表，并重新绘制该行。如果提供了数值参数，则在路径名展开之前附加一个‘ * ’。

display-shell-version (C-x C-v)
Display version information about the current instance of Bash.

显示有关 Bash 当前实例的版本信息。

shell-expand-line (M-C-e)
Expand the line as the shell does. This performs alias and history expansion as well as all of the shell word expansions (see Shell Expansions).

像 shell 那样展开这一行。这将执行别名和历史扩展以及所有 Shell 字扩展(参见 Shell 扩展)。

history-expand-line (M-^)
Perform history expansion on the current line.

在当前行上执行历史扩展。

magic-space ()
Perform history expansion on the current line and insert a space (see History Interaction).

对当前行执行历史展开并插入一个空格(请参阅历史交互)。

alias-expand-line ()
Perform alias expansion on the current line (see Aliases).

对当前行执行别名展开(请参阅别名)。

history-and-alias-expand-line ()
Perform history and alias expansion on the current line.

在当前行上执行历史记录和别名展开。

insert-last-argument (M-. or M-_)
A synonym for yank-last-arg.

Yank-last-arg 的同义词。

operate-and-get-next (C-o)
Accept the current line for execution and fetch the next line relative to the current line from the history for editing. A numeric argument, if supplied, specifies the history entry to use instead of the current line.

接受当前行以便执行，并从历史记录中提取相对于当前行的下一行以便进行编辑。如果提供了数值参数，则指定要使用的历史记录项，而不是当前行。

edit-and-execute-command (C-x C-e)
Invoke an editor on the current command line, and execute the result as shell commands. Bash attempts to invoke $VISUAL, $EDITOR, and emacs as the editor, in that order.

在当前命令行上调用编辑器，并以 shell 命令的形式执行结果。Bash 试图以这种顺序调用 $VISUAL、 $EDITOR 和 emacs 作为编辑器。

Next: Programmable Completion, Previous: Bindable Readline Commands, Up: Command Line Editing   [Contents][Index]

下一步: 可编程完成，上一步: 可绑定读行命令，向上: 命令行编辑[内容][索引]

8.5 Readline vi Mode
While the Readline library does not have a full set of vi editing functions, it does contain enough to allow simple editing of the line. The Readline vi mode behaves as specified in the POSIX standard.

虽然 Readline 库没有一整套 vi 编辑函数，但是它包含的内容足以对该行进行简单的编辑。Readline vi 模式的行为与 POSIX 标准中指定的一样。

In order to switch interactively between emacs and vi editing modes, use the ‘set -o emacs’ and ‘set -o vi’ commands (see The Set Builtin). The Readline default is emacs mode.

为了在 emacs 和 vi 编辑模式之间交互切换，可以使用 Set-o emacs 和 Set-o vi 命令(参见 Set Builtin)。Readline 默认是 emacs 模式。

When you enter a line in vi mode, you are already placed in ‘insertion’ mode, as if you had typed an ‘i’. Pressing ESC switches you into ‘command’ mode, where you can edit the text of the line with the standard vi movement keys, move to previous history lines with ‘k’ and subsequent lines with ‘j’, and so forth.

当您以 vi 模式输入一行时，您已经处于“插入”模式，就像您输入了一个“ i”一样。按 ESC 键可以将你切换到命令模式，你可以使用标准的 vi 移动键编辑行的文本，移动到以前的历史行中使用‘ k’ ，后面的行中使用‘ j’等等。

Next: Programmable Completion Builtins, Previous: Readline vi Mode, Up: Command Line Editing   [Contents][Index]

下一步: 可编程完成内建，上一步: Readline vi 模式，向上: 命令行编辑[内容][索引]

8.6 Programmable Completion
8.6可编程完成
When word completion is attempted for an argument to a command for which a completion specification (a compspec) has been defined using the complete builtin (see Programmable Completion Builtins), the programmable completion facilities are invoked.

当使用完整内建语言(参见可编程完成内建语言)定义了完成规范(compspec)的命令的参数的单词完成时，调用可编程完成设施。

First, the command name is identified. If a compspec has been defined for that command, the compspec is used to generate the list of possible completions for the word. If the command word is the empty string (completion attempted at the beginning of an empty line), any compspec defined with the -E option to complete is used. If the command word is a full pathname, a compspec for the full pathname is searched for first. If no compspec is found for the full pathname, an attempt is made to find a compspec for the portion following the final slash. If those searches do not result in a compspec, any compspec defined with the -D option to complete is used as the default. If there is no default compspec, Bash attempts alias expansion on the command word as a final resort, and attempts to find a compspec for the command word from any successful expansion

首先，标识命令名。如果已经为该命令定义了 compspec，则使用 compspec 生成该单词的可能完成列表。如果命令字是空字符串(在空行开头尝试完成) ，则使用任何使用 -e 选项定义的 comspec 来完成。如果命令字是完整路径名，则首先搜索完整路径名的 comspec。如果没有找到完整路径名的 compspec，则尝试为最后一个斜杠后的部分找到 compspec。如果这些搜索没有产生 compspec，则使用要完成的 -d 选项定义的任何 compspec 作为默认值。如果没有缺省的 comspec，Bash 会尝试在命令字上进行别名扩展，并尝试从任何成功的扩展中为命令字找到 comspec

Once a compspec has been found, it is used to generate the list of matching words. If a compspec is not found, the default Bash completion described above (see Commands For Completion) is performed.

一旦找到 comspec，就用它来生成匹配单词列表。如果没有找到 comspec，则执行上面描述的缺省 Bash 完成(请参阅完成命令)。

First, the actions specified by the compspec are used. Only matches which are prefixed by the word being completed are returned. When the -f or -d option is used for filename or directory name completion, the shell variable FIGNORE is used to filter the matches. See Bash Variables, for a description of FIGNORE.

首先，使用 compspec 指定的操作。只返回以正在完成的单词为前缀的匹配项。当使用-f 或-d 选项完成文件名或目录名时，将使用 shell 变量 FIGNORE 来筛选匹配项。有关 FIGNORE 的描述，请参见 Bash Variables。

Any completions specified by a filename expansion pattern to the -G option are generated next. The words generated by the pattern need not match the word being completed. The GLOBIGNORE shell variable is not used to filter the matches, but the FIGNORE shell variable is used.

接下来将生成由 -g 选项的文件名展开模式指定的任何完成。模式生成的单词不需要与正在完成的单词匹配。Globalignore shell 变量不用于筛选匹配，但使用 FIGNORE shell 变量。

Next, the string specified as the argument to the -W option is considered. The string is first split using the characters in the IFS special variable as delimiters. Shell quoting is honored within the string, in order to provide a mechanism for the words to contain shell metacharacters or characters in the value of IFS. Each word is then expanded using brace expansion, tilde expansion, parameter and variable expansion, command substitution, and arithmetic expansion, as described above (see Shell Expansions). The results are split using the rules described above (see Word Splitting). The results of the expansion are prefix-matched against the word being completed, and the matching words become the possible completions.

接下来，考虑指定为 -w 选项的参数的字符串。字符串首先使用 IFS 特殊变量中的字符作为分隔符进行拆分。在字符串中引用 Shell，以便为字符提供一种机制，使其包含 Shell 元字符或 IFS 值中的字符。然后，每个单词使用大括号展开、波浪线展开、参数和变量展开、指令替代展开和算术展开展开，如上所述(见 Shell 展开)。结果使用上面描述的规则进行分割(参见 Word 分割)。扩展的结果是前缀与正在完成的词匹配，并且匹配的词成为可能的完成词。

After these matches have been generated, any shell function or command specified with the -F and -C options is invoked. When the command or function is invoked, the COMP_LINE, COMP_POINT, COMP_KEY, and COMP_TYPE variables are assigned values as described above (see Bash Variables). If a shell function is being invoked, the COMP_WORDS and COMP_CWORD variables are also set. When the function or command is invoked, the first argument ($1) is the name of the command whose arguments are being completed, the second argument ($2) is the word being completed, and the third argument ($3) is the word preceding the word being completed on the current command line. No filtering of the generated completions against the word being completed is performed; the function or command has complete freedom in generating the matches.

生成这些匹配后，将调用用 -f 和 -c 选项指定的任何 shell 函数或命令。当命令或函数被调用时，COMP _ line、 COMP _ point、 COMP _ key 和 COMP _ type 变量被赋值，如上所述(参见 Bash 变量)。如果正在调用 shell 函数，则还将设置 comp_words 和 comp_cword 变量。当调用函数或命令时，第一个参数($1)是参数正在完成的命令的名称，第二个参数($2)是正在完成的单词，第三个参数($3)是当前命令行中正在完成的单词前面的单词。不对正在完成的单词执行生成的补全过滤; 函数或命令在生成匹配时有完全的自由。

Any function specified with -F is invoked first. The function may use any of the shell facilities, including the compgen and compopt builtins described below (see Programmable Completion Builtins), to generate the matches. It must put the possible completions in the COMPREPLY array variable, one per array element.

首先调用用-f 指定的任何函数。该函数可以使用任何外壳设施，包括下面描述的复合和复合内置程序(参见可编程完成内置程序)来生成匹配。它必须将可能的完成放在 COMPREPLY 数组变量中，每个数组元素一个。

Next, any command specified with the -C option is invoked in an environment equivalent to command substitution. It should print a list of completions, one per line, to the standard output. Backslash may be used to escape a newline, if necessary.

接下来，任何使用-c 选项指定的命令都会在相当于指令替代的环境中调用。它应该在标准输出中打印完成情况的列表，每行一个。如果需要，反斜杠可以用来转义换行符。

After all of the possible completions are generated, any filter specified with the -X option is applied to the list. The filter is a pattern as used for pathname expansion; a ‘&’ in the pattern is replaced with the text of the word being completed. A literal ‘&’ may be escaped with a backslash; the backslash is removed before attempting a match. Any completion that matches the pattern will be removed from the list. A leading ‘!’ negates the pattern; in this case any completion not matching the pattern will be removed. If the nocasematch shell option (see the description of shopt in The Shopt Builtin) is enabled, the match is performed without regard to the case of alphabetic characters.

在生成所有可能的完成之后，将使用-x 选项指定的任何筛选器应用于列表。过滤器是用于路径名扩展的模式; 模式中的“ & ”被替换为正在完成的单词的文本。文字“ & ”可以用反斜杠进行转义; 在尝试匹配之前，反斜杠将被删除。任何与该模式匹配的补全都将从列表中删除。一个引导性的“ ! ”否定模式; 在这种情况下，任何不匹配模式的完成都将被删除。如果启用了 nocasematch shell 选项(参见 Shopt Builtin 中对 Shopt 的描述) ，匹配将不考虑字母字符的大小写。

Finally, any prefix and suffix specified with the -P and -S options are added to each member of the completion list, and the result is returned to the Readline completion code as the list of possible completions.

最后，用 -p 和 -s 选项指定的任何前缀和后缀都被添加到完成列表的每个成员中，结果作为可能完成的列表返回给 Readline 完成代码。

If the previously-applied actions do not generate any matches, and the -o dirnames option was supplied to complete when the compspec was defined, directory name completion is attempted.

如果以前应用的操作没有生成任何匹配，并且在定义 compspec 时提供了 -o dirnames 选项来完成，则尝试完成目录名。

If the -o plusdirs option was supplied to complete when the compspec was defined, directory name completion is attempted and any matches are added to the results of the other actions.

如果在定义 compspec 时提供了 -o plusdirs 选项来完成，则尝试完成目录名，并将任何匹配添加到其他操作的结果中。

By default, if a compspec is found, whatever it generates is returned to the completion code as the full set of possible completions. The default Bash completions are not attempted, and the Readline default of filename completion is disabled. If the -o bashdefault option was supplied to complete when the compspec was defined, the default Bash completions are attempted if the compspec generates no matches. If the -o default option was supplied to complete when the compspec was defined, Readline’s default completion will be performed if the compspec (and, if attempted, the default Bash completions) generate no matches.

默认情况下，如果找到了 comspec，它生成的任何内容都将作为完成代码的完整集返回。不尝试默认的 Bash 完成，并且禁用文件名完成的 Readline 默认值。如果在定义 compspec 时提供了 -o bashdefault 选项来完成，那么如果 compspec 没有生成匹配，则尝试默认的 Bash 补全。如果在定义 compspec 时提供了 -o 默认选项来完成，那么如果 compspec (如果尝试，则默认 Bash 补全)没有生成匹配，那么将执行 Readline 的默认补全。

When a compspec indicates that directory name completion is desired, the programmable completion functions force Readline to append a slash to completed names which are symbolic links to directories, subject to the value of the mark-directories Readline variable, regardless of the setting of the mark-symlinked-directories Readline variable.

当 compspec 指出需要完成目录名称时，可编程完成函数强制 Readline 在完成名称后附加一个斜杠，这些完成名称是指向目录的符号链接，受标记-目录 Readline 变量值的限制，而不管标记-符号链接-目录 Readline 变量的设置如何。

There is some support for dynamically modifying completions. This is most useful when used in combination with a default completion specified with -D. It’s possible for shell functions executed as completion handlers to indicate that completion should be retried by returning an exit status of 124. If a shell function returns 124, and changes the compspec associated with the command on which completion is being attempted (supplied as the first argument when the function is executed), programmable completion restarts from the beginning, with an attempt to find a new compspec for that command. This allows a set of completions to be built dynamically as completion is attempted, rather than being loaded all at once.

对于动态修改完成，有一些支持。当结合使用-d 指定的缺省完成时，这是最有用的。作为完成处理程序执行的 shell 函数可以指示应该通过返回退出状态124来重试完成。如果一个 shell 函数返回124，并更改了与尝试完成的命令相关联的 compspec (在函数执行时作为第一个参数提供) ，可编程完成将从头开始重新启动，并尝试为该命令找到一个新的 compspec。这允许在尝试完成时动态地构建一组完成，而不是一次性全部加载。

For instance, assuming that there is a library of compspecs, each kept in a file corresponding to the name of the command, the following default completion function would load completions dynamically:

例如，假设有一个 compspecs 库，每个库都保存在与命令名相对应的文件中，下面的缺省补全函数将动态加载补全:

_completion_loader()
{
    . "/etc/bash_completion.d/$1.sh" >/dev/null 2>&1 && return 124
}
complete -D -F _completion_loader -o bashdefault -o default
Next: A Programmable Completion Example, Previous: Programmable Completion, Up: Command Line Editing   [Contents][Index]

下一步: 可编程完成示例，上一步: 可编程完成，向上: 命令行编辑[目录][索引]

8.7 Programmable Completion Builtins
8.7可编程完成内置程序
Three builtin commands are available to manipulate the programmable completion facilities: one to specify how the arguments to a particular command are to be completed, and two to modify the completion as it is happening.

有三个内置命令可用于操作可编程完成设施: 一个用于指定如何完成特定命令的参数，另外两个用于修改正在执行的完成。

compgen
compgen [option] [word]
Generate possible completion matches for word according to the options, which may be any option accepted by the complete builtin with the exception of -p and -r, and write the matches to the standard output. When using the -F or -C options, the various shell variables set by the programmable completion facilities, while available, will not have useful values.

根据选项为单词生成可能的完成匹配，这可能是除 -p 和-r 之外的完成内建接受的任何选项，并将匹配写入标准输出。当使用-f 或-c 选项时，由可编程完成设施设置的各种 shell 变量，尽管可用，但没有有用的值。

The matches will be generated in the same way as if the programmable completion code had generated them directly from a completion specification with the same flags. If word is specified, only those completions matching word will be displayed.

匹配将以相同的方式生成，就像可编程完成代码直接从具有相同标志的完成规范生成它们一样。如果指定了单词，则只显示与单词匹配的补全。

The return value is true unless an invalid option is supplied, or no matches were generated.

除非提供了无效选项，或者没有生成匹配，否则返回值为 true。

complete
complete [-abcdefgjksuv] [-o comp-option] [-DEI] [-A action] [-G globpat]
[-W wordlist] [-F function] [-C command] [-X filterpat]
[-P prefix] [-S suffix] name [name …]
complete -pr [-DEI] [name …]
Specify how arguments to each name should be completed. If the -p option is supplied, or if no options are supplied, existing completion specifications are printed in a way that allows them to be reused as input. The -r option removes a completion specification for each name, or, if no names are supplied, all completion specifications. The -D option indicates that other supplied options and actions should apply to the “default” command completion; that is, completion attempted on a command for which no completion has previously been defined. The -E option indicates that other supplied options and actions should apply to “empty” command completion; that is, completion attempted on a blank line. The -I option indicates that other supplied options and actions should apply to completion on the initial non-assignment word on the line, or after a command delimiter such as ‘;’ or ‘|’, which is usually command name completion. If multiple options are supplied, the -D option takes precedence over -E, and both take precedence over -I. If any of -D, -E, or -I are supplied, any other name arguments are ignored; these completions only apply to the case specified by the option.

指定如何完成每个名称的参数。如果提供了 -p 选项，或者没有提供选项，则打印现有的完成规范，以允许将其作为输入重用。R 选项删除每个名称的完成规范，如果没有提供名称，则删除所有完成规范。D 选项表明，其他提供的选项和操作应该适用于“默认”命令完成; 也就是说，在以前没有定义完成的命令上尝试完成。E 选项表示其他提供的选项和操作应该适用于“空”命令完成; 也就是说，在空行上尝试完成。I 选项表明，其他提供的选项和操作应该适用于完成行上的初始非赋值字，或者在“ ; ”或“ | ”等命令分隔符之后完成，这通常是命令名完成。如果提供了多个选项,-d 选项优先于-e，并且两者都优先于-i。如果提供任何-d、-e 或-i，则忽略其他任何名称参数; 这些补全只适用于选项指定的大小写。

The process of applying these completion specifications when word completion is attempted is described above (see Programmable Completion).

当试图完成单词时，应用这些完成规范的过程被描述在上面(见可编程完成)。

Other options, if specified, have the following meanings. The arguments to the -G, -W, and -X options (and, if necessary, the -P and -S options) should be quoted to protect them from expansion before the complete builtin is invoked.

如果指定了其他选项，则具有以下含义。应该引用-g、-w 和-x 选项的参数(如果必要的话，还应该引用-p 和-s 选项) ，以便在调用完整内建之前保护它们不被扩展。

-o comp-option
The comp-option controls several aspects of the compspec’s behavior beyond the simple generation of completions. comp-option may be one of:

Comp-option 控制 comspec 行为的几个方面，而不仅仅是简单地生成完成。 comp-option 可能是:

bashdefault
Perform the rest of the default Bash completions if the compspec generates no matches.

如果 compspec 没有生成匹配，则执行其余的缺省 Bash 完成。

default
Use Readline’s default filename completion if the compspec generates no matches.

如果 compspec 没有生成匹配，则使用 Readline 的默认文件名补全。

dirnames
Perform directory name completion if the compspec generates no matches.

如果 comspec 生成不匹配，则执行目录名完成。

filenames
Tell Readline that the compspec generates filenames, so it can perform any filename-specific processing (like adding a slash to directory names, quoting special characters, or suppressing trailing spaces). This option is intended to be used with shell functions specified with -F.

告诉 Readline，compspec 生成文件名，这样它就可以执行任何特定于文件名的处理(比如向目录名添加斜线、引用特殊字符或者删除尾随空格)。此选项用于指定 -f 的 shell 函数。

noquote
Tell Readline not to quote the completed words if they are filenames (quoting filenames is the default).

告诉 Readline，如果完成的单词是文件名，则不要引用它们(默认情况下引用文件名)。

nosort
Tell Readline not to sort the list of possible completions alphabetically.

告诉 Readline 不要按字母顺序对可能完成的列表排序。

nospace
Tell Readline not to append a space (the default) to words completed at the end of the line.

告诉 Readline 不要将空格(默认值)附加到行尾完成的单词。

plusdirs
After any matches defined by the compspec are generated, directory name completion is attempted and any matches are added to the results of the other actions.

在生成由 comspec 定义的任何匹配之后，将尝试完成目录名，并将任何匹配添加到其他操作的结果中。

-A action
The action may be one of the following to generate a list of possible completions:

该操作可以是下列操作之一，以生成一个可能完成的列表:

alias
Alias names. May also be specified as -a.

别名。也可以指定为-a。

arrayvar
Array variable names.

数组变量名。

binding
Readline key binding names (see Bindable Readline Commands).

读行键绑定名称(请参阅可绑定的读行命令)。

builtin
Names of shell builtin commands. May also be specified as -b.

Shell 内置命令的名称。也可以指定为-b。

command
Command names. May also be specified as -c.

命令名。也可以指定为 -c。

directory
Directory names. May also be specified as -d.

目录名称。也可以指定为-d。

disabled
Names of disabled shell builtins.

禁用 shell 内置程序的名称。

enabled
Names of enabled shell builtins.

启用 shell 内置语言的名称。

export
Names of exported shell variables. May also be specified as -e.

导出的 shell 变量的名称。也可以指定为 -e。

file
File names. May also be specified as -f.

文件名。也可以指定为 -f。

function
Names of shell functions.

Shell 函数的名称。

group
Group names. May also be specified as -g.

组名。也可以指定为 -g。

helptopic
Help topics as accepted by the help builtin (see Bash Builtins).

帮助内建接受的帮助主题(参见 Bash 内建)。

hostname
Hostnames, as taken from the file specified by the HOSTFILE shell variable (see Bash Variables).

主机名，取自 hostfileshell 变量指定的文件(参见 Bash 变量)。

job
Job names, if job control is active. May also be specified as -j.

作业名称，如果作业控制处于活动状态。也可以指定为 -j。

keyword
Shell reserved words. May also be specified as -k.

外壳保留字。也可以指定为 -k。

running
Names of running jobs, if job control is active.

如果作业控制处于活动状态，则运行作业的名称。

service
Service names. May also be specified as -s.

服务名称。也可以指定为-s。

setopt
Valid arguments for the -o option to the set builtin (see The Set Builtin).

对于 Set 内建的-o 选项的有效参数(参见 The Set Builtin)。

shopt
Shell option names as accepted by the shopt builtin (see Bash Builtins).

外壳选项的名称被 shopt 内建接受(参见 Bash 内建)。

signal
Signal names.

信号名称。

stopped
Names of stopped jobs, if job control is active.

如果作业控制处于活动状态，则为已停止作业的名称。

user
User names. May also be specified as -u.

用户名。也可以指定为 -u。

variable
Names of all shell variables. May also be specified as -v.

所有 shell 变量的名称。也可以指定为 -v。

-C command
command is executed in a subshell environment, and its output is used as the possible completions.

命令在子 shell 环境中执行，其输出用作可能的补充。

-F function
The shell function function is executed in the current shell environment. When it is executed, $1 is the name of the command whose arguments are being completed, $2 is the word being completed, and $3 is the word preceding the word being completed, as described above (see Programmable Completion). When it finishes, the possible completions are retrieved from the value of the COMPREPLY array variable.

Shell 函数在当前 shell 环境中执行。执行时，$1是参数正在完成的命令的名称，$2是正在完成的单词，$3是正在完成的单词前面的单词，如上所述(参见 Programmable Completion)。完成后，从 COMPREPLY 数组变量的值检索可能的完成情况。

-G globpat
The filename expansion pattern globpat is expanded to generate the possible completions.

扩展文件名扩展模式 glopat 以生成可能的补充。

-P prefix
prefix is added at the beginning of each possible completion after all other options have been applied.

在应用所有其他选项后，在每个可能的完成时间开始时添加前缀。

-S suffix
suffix is appended to each possible completion after all other options have been applied.

后缀附加到每个可能的完成后，所有其他选项已被应用。

-W wordlist
The wordlist is split using the characters in the IFS special variable as delimiters, and each resultant word is expanded. The possible completions are the members of the resultant list which match the word being completed.

单词列表使用 IFS 特殊变量中的字符作为分隔符进行拆分，并展开每个结果单词。可能的完成是结果列表中与正在完成的单词匹配的成员。

-X filterpat
filterpat is a pattern as used for filename expansion. It is applied to the list of possible completions generated by the preceding options and arguments, and each completion matching filterpat is removed from the list. A leading ‘!’ in filterpat negates the pattern; in this case, any completion not matching filterpat is removed.

Filterpat 是用于文件名扩展的模式。它应用于由前面的选项和参数生成的可能完成列表，并从列表中删除每个完成匹配的筛选程序。一个引导性的“ ! ”在 filterpat 中否定模式; 在本例中，删除任何不匹配 filterpat 的完成。

The return value is true unless an invalid option is supplied, an option other than -p or -r is supplied without a name argument, an attempt is made to remove a completion specification for a name for which no specification exists, or an error occurs adding a completion specification.

返回值为 true，除非提供了无效的选项，提供了除-p 或-r 以外的选项而没有名称参数，尝试删除不存在规范的名称的完成规范，或添加完成规范时发生错误。

compopt
compopt [-o option] [-DEI] [+o option] [name]
Modify completion options for each name according to the options, or for the currently-executing completion if no names are supplied. If no options are given, display the completion options for each name or the current completion. The possible values of option are those valid for the complete builtin described above. The -D option indicates that other supplied options should apply to the “default” command completion; that is, completion attempted on a command for which no completion has previously been defined. The -E option indicates that other supplied options should apply to “empty” command completion; that is, completion attempted on a blank line. The -I option indicates that other supplied options should apply to completion on the initial non-assignment word on the line, or after a command delimiter such as ‘;’ or ‘|’, which is usually command name completion.

根据选项修改每个名称的完成选项，如果没有提供名称，则修改当前正在执行的完成选项。如果没有给出选项，则显示每个名称或当前完成的完成选项。可能的值的选项是那些有效的完整的内置上述。D 选项表明，其他提供的选项应该应用于“默认”命令完成; 也就是说，在以前没有定义完成的命令上尝试完成。E 选项表示其他提供的选项应该适用于“空”命令完成; 即在空行上尝试完成。I 选项指示其他提供的选项应该应用于完成行上的初始非赋值字，或者在“ ; ”或“ | ”等命令分隔符之后，这通常是命令名完成。

If multiple options are supplied, the -D option takes precedence over -E, and both take precedence over -I

如果提供了多个选项,-d 选项优先于-e，两者都优先于-i

The return value is true unless an invalid option is supplied, an attempt is made to modify the options for a name for which no completion specification exists, or an output error occurs.

返回值为 true，除非提供了无效选项、尝试修改不存在完成规范的名称的选项或发生输出错误。

Previous: Programmable Completion Builtins, Up: Command Line Editing   [Contents][Index]

上一篇: 可编程完成内建，向上: 命令行编辑[内容][索引]

8.8 A Programmable Completion Example
8.8 a 可编程完成示例
The most common way to obtain additional completion functionality beyond the default actions complete and compgen provide is to use a shell function and bind it to a particular command using complete -F.

在缺省操作完成和 compgen 提供之外，获得额外完成功能的最常用方法是使用 shell 函数，并使用 complete-f 将其绑定到特定的命令。

The following function provides completions for the cd builtin. It is a reasonably good example of what shell functions must do when used for completion. This function uses the word passed as $2 to determine the directory name to complete. You can also use the COMP_WORDS array variable; the current word is indexed by the COMP_CWORD variable.

下面的函数提供 cd 内建的完成。这是一个相当好的例子，说明了 shell 函数在用于完成时必须执行哪些操作。此函数使用作为 $2传递的单词来确定要完成的目录名称。还可以使用 comp_words 数组变量; 当前单词通过 comp_cword 变量进行索引。

The function relies on the complete and compgen builtins to do much of the work, adding only the things that the Bash cd does beyond accepting basic directory names: tilde expansion (see Tilde Expansion), searching directories in $CDPATH, which is described above (see Bourne Shell Builtins), and basic support for the cdable_vars shell option (see The Shopt Builtin). _comp_cd modifies the value of IFS so that it contains only a newline to accommodate file names containing spaces and tabs – compgen prints the possible completions it generates one per line.

该函数依赖于完整的 compgen 内置程序来完成大部分工作，只添加 Bash cd 除了接受基本目录名之外所做的事情: 波浪形扩展(参见 Tilde Expansion)、在 $CDPATH 中搜索目录(参见 Bourne Shell Builtins) ，以及对 cdable _ vars Shell 选项的基本支持(参见 The Shopt Builtin)。_ comp _ cd 修改 IFS 的值，使其只包含一个换行符，以容纳包含空格的文件名，并且制表符打印它每行生成一个可能的补全。

Possible completions go into the COMPREPLY array variable, one completion per array element. The programmable completion system retrieves the completions from there when the function returns.

可能的完成进入 COMPREPLY 数组变量，每个数组元素一个完成。当函数返回时，可编程完成系统从那里检索完成情况。

# A completion function for the cd builtin
# based on the cd completion function from the bash_completion package
_comp_cd()
{
    local IFS=$' \t\n'    # normalize IFS
    local cur _skipdot _cdpath
    local i j k

    # Tilde expansion, which also expands tilde to full pathname
    case "$2" in
    \~*)    eval cur="$2" ;;
    *)      cur=$2 ;;
    esac

    # no cdpath or absolute pathname -- straight directory completion
    if [[ -z "${CDPATH:-}" ]] || [[ "$cur" == @(./*|../*|/*) ]]; then
        # compgen prints paths one per line; could also use while loop
        IFS=$'\n'
        COMPREPLY=( $(compgen -d -- "$cur") )
        IFS=$' \t\n'
    # CDPATH+directories in the current directory if not in CDPATH
    else
        IFS=$'\n'
        _skipdot=false
        # preprocess CDPATH to convert null directory names to .
        _cdpath=${CDPATH/#:/.:}
        _cdpath=${_cdpath//::/:.:}
        _cdpath=${_cdpath/%:/:.}
        for i in ${_cdpath//:/$'\n'}; do
            if [[ $i -ef . ]]; then _skipdot=true; fi
            k="${#COMPREPLY[@]}"
            for j in $( compgen -d -- "$i/$cur" ); do
                COMPREPLY[k++]=${j#$i/}        # cut off directory
            done
        done
        $_skipdot || COMPREPLY+=( $(compgen -d -- "$cur") )
        IFS=$' \t\n'
    fi

    # variable names if appropriate shell option set and no completions
    if shopt -q cdable_vars && [[ ${#COMPREPLY[@]} -eq 0 ]]; then
        COMPREPLY=( $(compgen -v -- "$cur") )
    fi

    return 0
}
We install the completion function using the -F option to complete:

我们使用-f 选项安装完成函数来完成:

# Tell readline to quote appropriate and append slashes to directories;
# use the bash default completion for other arguments
complete -o filenames -o nospace -o bashdefault -F _comp_cd cd
Since we’d like Bash and Readline to take care of some of the other details for us, we use several other options to tell Bash and Readline what to do. The -o filenames option tells Readline that the possible completions should be treated as filenames, and quoted appropriately. That option will also cause Readline to append a slash to filenames it can determine are directories (which is why we might want to extend _comp_cd to append a slash if we’re using directories found via CDPATH: Readline can’t tell those completions are directories). The -o nospace option tells Readline to not append a space character to the directory name, in case we want to append to it. The -o bashdefault option brings in the rest of the "Bash default" completions – possible completion that Bash adds to the default Readline set. These include things like command name completion, variable completion for words beginning with ‘$’ or ‘${’, completions containing pathname expansion patterns (see Filename Expansion), and so on.

由于希望 Bash 和 Readline 为我们处理其他一些细节，因此我们使用其他几个选项来告诉 Bash 和 Readline 该做什么。O 文件名选项告诉 Readline，可能的补充应该被视为文件名，并适当地加上引号。这个选项还会导致 Readline 在文件名中附加一个斜杠，它可以确定哪些是目录(这就是为什么如果我们使用通过 CDPATH 找到的目录，我们可能需要扩展 _comp _ cd 来附加一个斜杠: Readline 不能告诉那些完整的目录是目录)。O nospace 选项告诉 Readline 不要将空格字符附加到目录名称，以防我们想要附加到它。O bashdefault 选项引入其余的“ Bash default”补全——可能是 Bash 添加到默认 Readline 集中的补全。这些包括命令名完成、以“ $”或“ ${”开头的单词的变量完成、包含路径名扩展模式的完成(参见文件名扩展)等等。

Once installed using complete, _comp_cd will be called every time we attempt word completion for a cd command.

一旦使用 complete 安装完成，每次我们尝试为 cd 命令执行单词补全时，都会调用 _comp _ cd。

Many more examples – an extensive collection of completions for most of the common GNU, Unix, and Linux commands – are available as part of the bash_completion project. This is installed by default on many GNU/Linux distributions. Originally written by Ian Macdonald, the project now lives at https://github.com/scop/bash-completion/. There are ports for other systems such as Solaris and Mac OS X.

作为 bash _ completion 项目的一部分，还有更多的示例——大多数常用 GNU、 Unix 和 Linux 命令的完成集合——可用。在许多 GNU/Linux 发行版中，默认情况下都是这样安装的。这个项目最初是由 Ian Macdonald 编写的，现在在 https://github.com/scop/bash-completion/。还有其他系统的端口，比如 Solaris 和 macosx。

An older version of the bash_completion package is distributed with bash in the examples/complete subdirectory.

Bash _ completion 包的旧版本在 examples/complete 子目录中与 bash 一起发布。

Next: Installing Bash, Previous: Command Line Editing, Up: Top   [Contents][Index]

下一步: 安装 Bash，上一步: 命令行编辑，上一步: Top [ Contents ][ Index ]

